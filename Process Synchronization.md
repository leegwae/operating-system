# Process Synchronization

## 경쟁 상태

> 경쟁 상태와 임계구역의 정의, 해결 방법을 알아본다.

**경쟁 상태(race condition)**는 공유 자원에 두 개 이상의 프로세스가 접근할 때, 그 순서에 따라 결과가 달라지는 상황을 뜻한다. **임계구역(critical section)**은 공유 메모리를 접근하는 프로그램 부분이다. 경쟁 상태를 피하려면 두 프로세스가 동시에 임계구역에 존재하지 않아야한다. 이를 **상호배제(mutual exclusion)**라고 하며, 한 프로세스가 임계구역에 진입하여 공유 메모리를 읽고 쓸 동안 다른 프로세스는 그러지 못하게 막아 구현한다. 상호배제만으로 경쟁 상태를 피할 수 있으나, 병렬 프로세스가 효율적이고 정확하게 공유 자원을 사용할 수 있도록 두 가지 조건이 더 필요하다. 첫번째, 임계구역 외부에서 실행되고 있는 프로세스가 다른 프로세스의 진입을 막으면 안된다(임계구역이 비어있으면 진입할 수 있어야 한다). 이를 **진행(progress)**이라고 한다. 두번째, 프로세스는 언젠가는 임계구역에 진입할 수 있어야 한다. 이를 **한계 대기(bounded waiting)**라고 한다.



정리하여 여러 프로세스가 공유 자원에 동시에 접근하는 문제(임계구역 문제)에 대한 바람직한 해결책은 총 세 가지로 상호배제, 진행, 한계 대기이다. 상호배제로 경쟁 상태를 피할 수 있으며, 이에 더하여 진행과 한계 대기로 병렬 프로세스가 효율적이고 정확하게 공유 자원을 사용할 수 있다.



## 상호 배제 구현하기

> 상호 배제를 구현하는 인터럽트 끄기, 락 변수 사용하기, 스핀 락 사용하기(바쁜 대기)와 각각의 문제점을 알아본다.

첫번째, 프로세스가 임계구역에 진입하면 인터럽트를 꺼서 문맥 교환이 일어나지 않도록 하고 임계구역에서 나가기 적전에 인터럽트를 켠다. 그러나 인터럽트를 끄고 켜는 것은 커널의 고유 권한이다. 또한 프로세스가 인터럽트를 건다면 자신을 실행하는 CPU에만 영향을 끼치므로 CPU가 여러 개일 경우 유효하지 않은 방법이다.

두번째, 공유 락 변수를 확인하여 `0`이면 `1`로 설정하고 임계구역에 진입하고 다른 프로세스는 락이 `0`이 될 때까지 기다린다. 그런데 다음과 같은 경우를 생각해보자. `A` 프로세스가 임계구역에 진입하기 위해 락을 걸기 직전, 다른 프로세스 `B`가 스케줄되어 락을 건다. 그리고 다시 스케줄된 `A`가 락을 건다면 임계구역에는 `A`와 `B`가 동시에 존재하게 된다.

세번째, 두 프로세스는 각자 `0`과 `1`이라는 값을 가지고 락이 해당 값이 될 때까지 기다린다. 이렇게 변수가 특정 값이 될 때까지 검사하는 것을 **바쁜 대기(busy waiting)**라고 하며 바쁜 대기를 사용하는 락을 스핀 락(spin lock)이라고 한다. 프로세스는 자신의 락 값이 될 때까지 기다렸다가, 임계구역을 수행하고 락을 다른 프로세스의 값으로 설정하고 비임계구역을 수행한다. 그러나 다음과 같은 경우를 생각해보자. 프로세스 `A`는 임계구역을 떠나며 락을 `1`로 설정했다. 프로세스 `B`는 락이 `1`로 설정되었으니 재빨리 임계구역에 진입하여 일을 처리한 후 락을 `0`으로 설정하고 비임계구역을 수행중이다. 락은 `0`이고 두 프로세스는 비임계구역에 있다. `A`는 락이 `0`이되었으므로 임계구역을 수행한 후 락을 `1`로 설정한다. 락은 `1`이고 두 프로세스는 비임계구역에 있다. 그런데 `A`의 수행 속도가 빨라, 비임계구역의 일을 마치고 다시 락이 `0`이 되기를 기다린다. 즉, 프로세스의 수행 속도가 느리다면 다른 프로세스는 계속 기다려야한다. 이 경우 비임계구역의 프로세스 `B`가 `A`의 임계구역 진입을 막고 있다. 또다른 경우를 생각해보자. 프로세스 `A`는 프로세스 `B`보다 높은 우선순위를 가져 `A`가 준비 상태이면 항상 `A`가 수행된다. 그런데 `B`가 임계구역에 진입하고 `A`가 준비 상태가 되었다. `A`는 스케줄링 규칙에 따라 실행되어 임계구역에 진입하기 위해 바쁜 대기를 수행한다. 그러나 `B`는 `A`가 실행 중(바쁜 대기 중)이므로 스케줄 되지 못해 임계구역을 벗어나지 못하며 `A`는 `B`가 임계구역에서 벗어나지 못하니 영원히 대기하게 된다. 이러한 문제를 **우선순위 역전 문제(priority inversion problem)**라고 한다.



## 생산자-소비자 문제

> 바쁜 대기 대신 블로킹으로 CPU 시간을 낭비하지 않는 sleep-wakeup 메커니즘을 생산자-소비자 문제로 이해하고 이 메커니즘의 문제점을 알아본다.

sleep-wakeup 메커니즘으로 바쁜 대기의 문제를 해결해보자. `생산자` 프로세스와 `소비자` 프로세스는 버퍼를 공유한다. `생산자`는 버퍼가 꽉 차면 잠들고 `소비자`는 버퍼가 텅 비면 잠든다. `소비자`가 데이터를 하나 꺼내 버퍼에 빈 공간이 생기면 생산자를 깨우고 `생산자`는 데이터를 하나 만들어 버퍼에 데이터가 한 개 있으면 소비자를 깨운다. 그런데 버퍼의 데이터 개수를 저장하는 변수에 경쟁 상태가 발생할 수 있다. 버퍼가 비고 소비자는 개수가 `0`임을 알았다. 이때 스케줄러가 소비자를 중지시키고 생산자를 실행하는데, 생산자는 데이터를 버퍼에 추가하고 개수를 `1`로 증가시킨다. 이전에 개수가 `0`이었다면 당연히 소비자는 잠들었을 것이므로 생산자는 소비자를 깨운다. 그리고 스케줄러가 생산자를 중지시키고 소비자를 실행하는데, 소비자는 개수가 `0`이라고 알고 있으므로 잠들게 된다. 다시 스케줄러에 의해 생산자가 실행되고 생산자는 버퍼를 꽉 채운 후 잠든다. 생산자와 소비자는 영원히 잠들게 된다.