# Memory Management

## 메모리 계층 구조

![memory hierarchy](https://user-images.githubusercontent.com/57662010/194758429-156502d2-21a2-404c-8bdc-02420d7ba1db.JPG)

메모리 계층 구조(memory hierarchy)는 서로 다른 특성 메모리들을 계층 구조로 구성한 것이다. 레지스터, 캐시, 메인 메모리는 휘발성으로 전원이 끊기면 기록된 데이터가 모두 날라간다. 또한 CPU가 직접 접근할 수 있다. 디스크와 테이프는 비휘발성으로 전원이 공급되지 않아도 그 내용이 지워지지 않는다. CPU는 이들에 직접 접근할 수 없고 컨트롤러 등을 통하여 접근할 수 있다. 비휘발성 메모리는 휘발성 메모리에 비하여 그 크기가 매우 크지만 느리다. 휘발성 메모리는 비휘발성 메모리에 비하여 성능이 좋지만 크기가 매우 작으며 비싸다.

운영체제는 디스크로부터 실행할 프로세스의 코드와 데이터를 가져와 메인 메모리에 적재한다. CPU는 메모리로부터 데이터와 명령어를 가져와 레지스터에 적재하고 실행한다. 이때 메인 메모리에 접근하는 속도가 CPU에 비해 현저히 느리므로 중간에 고속의 캐시를 두어 성능 저하를 막는다.



## 메인 메모리

**메인 메모리(main memory)**는 CPU가 직접 접근할 수 있는 기억장치로 실행할 프로세스를 적재한다. 프로세스는 실행되기 위해 메모리에 적재되어야한다.



## 캐시

**캐시(cache)**는 CPU와 메모리 사이에 있는 고속의 기억장치로, CPU와 메모리의 속도 차이로 발생하는 성능 저하를 해결한다. 메모리에서 가져온 데이터를 캐시에 저장하여 CPU는 캐시부터 탐색한 후 원하는 데이터가 없으면 메인 메모리를 탐색한다. 원하는 데이터가 캐시에 있다면 **캐시 적중(hit)**이라고 한다.

### 지역성

캐시가 적중하지 않는다면 메모리에 접근하는 시간과 캐시에 접근하는 시간이 들어 기존 방식보다 오래 걸린다. 하지만 참조 지역성 때문에 일반적으로 캐시 적중률은 준수하다. **참조 지역성(Locality of Reference)**은 참조되었던 데이터나 관계가 있는 데이터가 가까운 미래에 다시 참조될 가능성이 높은 특성을 가리킨다. 참조 지역성에는 세 가지가 있다.

첫번째, **시간 지역성(temporal locality)**이다. 한 번 참조한 데이터는 다시 참조할 가능성이 높다는 뜻이다. 두번째, **공간 지역성(spatial locality)**이다. 참조된 데이터에 인접한 데이터를 미래에 참조할 가능성이 높다는 뜻이다. 세번째, **순차적 지역성(sequential locality)**이다. 데이터가 순차적으로 참조될 가능성이 높다는 뜻으로, 공간 지역성의 특별한 경우로 보기도 한다.

### 캐시 사상 기법

CPU는 워드 단위로 데이터를 가져오나, 캐시는 공간 지역성에 따라 인접한 데이터와 함께 블록 단위로 저장한다. 캐시 엔트리는 태그와 데이터로 구성된다. 캐시 사상(Cache Mapping) 기법은 메인 메모리의 데이터를 캐시 메모리의 어느 위치에 저장할 것인지 결정하는 방법이다.

첫번째, **완전 연관 사상(Fully Associative Mapping)**이다. 캐시 엔트리마다 비교 회로가 있으며 태그는 메인 메모리를 가리키는 주소를 저장한다. 이때 메인 메모리의 데이터는 캐시 메모리의 어느 위치에나 저장될 수 있다.  이 방식에서는 각각의 비교회로로 태그가 원하는 메모리 주소와 일치하는지 비교한다. 비교회로가 많아 성능은 매우 좋지만 같은 이유로 비싸다.

두번째, **직접 연관 사상(Direct Associative Mapping)**이다. 각 캐시 엔트리마다 인덱스가 있으며 비교 회로는 하나이다. 인덱스는 메모리 주소의 뒷부분을 가리키며, 남은 주소가 태그에 저장된다. 이때 메인 메모리의 데이터는 주소 뒷부분이 일치하는 인덱스의 엔트리에만 저장될 수 있다. 이 방식에서는 원하는 메모리의 주소 뒷부분을 인덱스로 해당하는 엔트리에 접근한다. 그리고 비교회로가 해당 엔트리의 태그가 남은 주소와 일치하는지 비교한다. 비교회로가 하나이므로 가격이 싸지만, 같은 이유로 성능이 좋지 않다.

세번째, **집합 연관 사상(Set Associative Mapping)**이다. 각 캐시 엔트리는 두 개의 태그-데이터 쌍을 가지며 비교 회로도 두 개 이다. 인덱스로 엔트리에 접근한 후 각각의 비교 회로가 태그를 비교하여 원하는 메모리의 주소와 일치하는지 비교한다. 완전 연관 사상과 직접 연관 사상에 대해 중간 정도의 성능을 제공한다.



## 멀티 프로그래밍에서의 메모리 관리 기법

오늘날의 멀티 프로그래밍에서 CPU는 여러 개의 프로세스를 번갈아가며 실행한다. 프로세스는 운영체제로부터 할당받은 메모리에 적재되어 실행되는데, 실제 RAM의 용량은 모든 프로세스들이 필요로 하는 메모리의 총 크기보다 작다. 이 문제를 해결하기 위해 메모리 관리 기법으로 스와핑과 가상 메모리을 사용해보자.

### 스와핑

스와핑(swapping)은 한 프로세스의 전체 수행 이미지를 메모리에 적재하여 실행하다가, 실행되지 않으면 하드디스크의 스왑 영역(swap space)로 내보내는(swap out) 방법이다. 스왑 영역의 프로세스는 다시 실행되면 스왑 영역에서 메모리로 올려진다(swap in).

스와핑의 단점은 외부 단편화가 생긴다는 것이다. 또한 메모리가 꽉 찼을 때 실행 중인 프로세스의 크기가 증가한다면 실행 중이던 다른 프로세스를 스왑 영역으로 보내야하는데, 스왑 영역마저 꽉 차 있으면 증가하려는 프로세스를 중단(suspend)시키거나 강제로 종료(kill)시켜야 한다. 이 문제를 해결하려면 프로세스가 실행 중에 증가할 것을 예상하여 메모리에 적재할 때 여분의 공간을 제공해주어야한다.

### 가상 메모리

스와핑 기법은 결국 물리 메모리 크기에 의해 많은 제약을 가진다. 물리 메모리의 크기에 제약받지 않는 방법은 없을까?

[가상 메모리](./Virtual Memory.md) 참고



## 참고

- 운영체제 강의 필기
- 운영체제론(노상혁, 이동희, 천홍석, 최동우 공역) 3장 메모리 관리
- 컴퓨터구조론 강의 필기
- 컴퓨터구조론 개정 5판(김종현 저) 1장 컴퓨터시스템 개요, 5장 기억장치
