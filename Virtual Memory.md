# Virtual Memory

오늘날의 멀티 프로그래밍에서 CPU는 여러 개의 프로세스를 번갈아가며 실행한다. 프로세스는 운영체제로부터 할당받은 메모리에 적재되어 실행되는데, 실제 RAM의 용량은 모든 프로세스들이 필요로 하는 메모리의 총 크기보다 작다.

**가상 메모리(virtual memory)** 기법을 통하여 이 문제를 해결해보자.



## 요구 페이징

가상 메모리는 전체 수행 이미지를 올리는 스와핑과 달리 실행에 필요한 프로세스의 일부만 적재한다. 이를 **요구 페이징(demand paging)** 방식이라고 한다.



## 가상 메모리와 가상 주소 공간

**가상 메모리(virtual memory)** 기법에서 프로세스는 무한한 크기의 가상 메모리와 CPU 자원을 독점하고 있다는 환상을 가진다. 프로그램이 참조하는 주소는 가상 주소(virtual address)로, 프로세스의 가상 주소 공간(virtual address space)은 가상 메모리 공간 전체이다. 가상 주소 공간의 0번지부터 프로세스의 주소 공간, 라이브러리의 주소 공간, 커널의 주소 공간이 순서대로 할당되어 있다.

가상 메모리 관리 기법에는 고정 분할 방식을 사용하는 페이징(paging) 기법과 가변 분할 방식을 사용하는 세그먼테이션(segmentation) 기법이 있다.



## 페이징

**페이징(paging)** 기법은 고정 분할 방식을 사용하는 가상 메모리 관리 기법이다. 가상 메모리는 고정된 크기로 나누어지는데 이 단위를 **페이지(page)**라고 하며, 실제 메모리에서 페이지와 동일한 크기의 **페이지 프레임(page frame)**이 페이지에 대응하게 된다.



## 가상 주소

**가상 주소(virtual address)**는 가상 메모리의 페이지를 가리키는 `페이지 번호`와 어디서부터 읽어야하는지 나타내는 `바이트 오프셋`으로 이루어진다. 이 주소로는 가상 메모리의 페이지에 대응하는 물리 메모리의 프레임에 접근할 수 없다. 따라서 가상 주소를 물리 주소로 변환해주어야 한다. 

MMU(Memory Management Unit)가 페이지 테이블(page table)을 사용하여 가상 주소를 물리 주소로 변환해주는데, 이것을 **동적 주소 변환(DAT; Dynamic Address Translation)**이라고 한다. 



## 페이지 테이블로 동적 주소 변환하기

**페이지 테이블(Page Table, Page Mapping Table)**은 인덱스로 페이지 번호를 사용하며 인덱스에 대응하는 페이지 테이블 엔트리에 페이지 프레임 번호(PFN; Page Frame Number)를 기록한다. 테이블의 크기는 가상 주소 공간의 크기에 따라 증가한다. 프로세스마다 페이지 테이블을 가지며, 페이지 테이블은 프로세스 상태의 일부이다. 기본적으로 페이지 테이블은 모두 DRAM에 기록된다.

페이지 테이블을 통한 동적 주소 변환 과정은 다음과 같다.

1. 가상 주소를 `페이지 번호`와 `오프셋`으로 구분한다.
2. 페이지 테이블에서 인덱스가 `페이지 번호`인 곳을 찾아 대응하는 엔트리에서 `프레임 번호`를 찾는다.
3. `프레임 번호`에 `오프셋`을 더하여 물리 주소로 변환한다.

### 페이지 테이블 엔트리

![image](https://user-images.githubusercontent.com/57662010/194643710-4dcd889e-2730-4190-85ce-2d2907a0a1aa.png)

**페이지 테이블 엔트리(PTE; Page Table Entry)**는 일반적으로 32비트 크기를 가지며, 페이지 프레임 번호 외에도 플래그들로 이루어져있다. 플래그의 종류는 CPU마다 다르며 일반적으로는 다음과 같다.

1. **present/absent 비트**(resident bit, valid/invalid bit): `1`이면 페이지가 프레임(메모리)에 적재되어 있으며(SWAP in) 기록된 프레임 번호가 유효하다는 것을 의미한다. `0`이면 페이지가 하드디스크의 SWAP 영역에 있으며(SWAP out) 이 프레임 번호 대신 디스크 주소가 기록되어있다는 것을 의미한다.
2. 보호 비트(protection bit): 페이지에 대하여 읽기, 쓰기, 실행이 가능한지 등의 여부를 표시한다.
3. **참조 비트(reference bit, clock bit, used bit)**: 프레임이 읽기 또는 쓰기로 접근되면 `1`로 설정한다. 운영체제가 주기적으로 `0`으로 클리어해준다. 페이지 폴트가 발생하여 운영체제가 페이지 교체 정책에 따라 교체 대상을 선택할 때 사용한다. (최근에 참조된 것보다 참조되지 않은 페이지를 교체하는 것이 성능에 좋기 때문이다.)
4. 캐시 무효화 비트(caching disabled bit): 페이지가 캐싱될 수 있는지 여부를 가리킨다.
5. **더티 비트(dirty bit)**: 수정 비트(modified bit)라고도 한다. `1`이면 프레임이 교체될 때 그 내용을 디스크에 기록한다. `0`이면 클린(clean) 상태로 디스크에 기록될 필요가 없다.

### PTBR

프로세스는 각자 페이지 테이블을 가지며 이 페이지 테이블들은 DRAM에 저장되어 있다. 따라서 MMU가 주소 변환을 할 때 프로세스에 해당하는 페이지 테이블을 찾을 수 있어야 한다. 

**PTBR(Page Table Base Register)**는 현재 실행 중인 프로세스의 페이지 테이블이 저장된 메모리의 시작 주소를 저장한다. PTBR은 프로세스 제어 블록(PCB; Process Control Block)에 저장되어 있으며 문맥 교환의 대상이다. PCB는 CPU 내부에 있으므로, PTBR을 사용하면 상당히 빠르게 페이지 테이블을 찾을 수 있다.



## 페이징 성능 개선

다양한 방법을 통해 페이징 기법의 성능을 개선해보자.

- [ ] 다단계 페이징(multilevel paging)
- [ ] 역 페이지 테이블(inverted page table)

### TLB

PTBR이 저장된 PCB와 MMU는 CPU 내부에 있는 반면, 페이지 테이블은 크기가 커서 CPU 외부에 있는 DRAM에 저장되어있다. 가상 메모리를 사용하지 않는 시스템에서는 메모리를 한 번만 접근해도 되었으나, 가상 메모리 시스템에서는 메모리를 두 번 접근해야 하므로 성능에 상당한 문제가 있었다.

이 문제를 해결하기 위해 CPU 내부에 페이지 테이블의 엔트리 중 일부를 가지는 일종의 캐시로서 **TLB(Translation Lookaside Buffer)**를 만들었다. MMU는 주소 변환을 하기 위해 TLB를 먼저 살핀 후 미스가 나면 DRAM의 페이지 테이블에서 검색한 후 찾은 엔트리를 TLB에 적재한다. TLB는 PTBR처럼 문맥 교환의 대상이다. 문맥 교환이 일어나면 TLB를 비운 후 PTBR을 바꾸므로 한동안 히트 rate가 낮아진다.



## 페이징 과정

페이징 기법을 사용하는 가상 메모리 시스템에서 프로세스를 실행하기까지의 과정은 다음과 같다.

1. 프로그램을 컴파일하여 실행 파일을 만든다. 이때 실행 파일의 주소는 가상 주소 0번지를 기준으로 한다.
2. 운영체제는 실행 파일을 실행하여 디스크의 SWAP 영역에 프로세스의 전체 수행 이미지를 만든다.
3. 메모리에 프로세스 주소 공간(힙, 스택)을 할당한 후, 라이브러리와 운영체제의 코드와 데이터를 매핑한다.
4. 원하는 페이지만 디스크의 SWAP 영역에서 읽어들여 메모리의 프레임에 넣고 실행한다.
5. 가상 주소를 참조하면 MMU가 페이지 테이블을 검색하고 valid 비트 검사를 한 후 물리 주소로 변환한다.
6. 물리 주소로 접근하여 데이터를 가져온다.



## 페이지 폴트

프로그램이 매핑되지 않은 주소를 참조하면, MMU는 페이지 테이블 엔트리의 present/absent 비트로 페이지가 유효하지 않다는 것(필요한 페이지가 메모리가 아니라 디스크의 SWAP 영역에 있음)을 파악하고 **페이지 폴트(page fault)** 예외를 발생시킨다.

페이지 폴트가 발생하면 페이지 폴트 핸들러가 실행된다.

1. CPU의 내부 회로는 디스크에 접근할 수 없으므로 CPU는 스스로 인터럽트를 걸어 운영체제로 JUMP한다.
2. 운영체제는 적재할 페이지를 SWAP 영역으로부터 읽어 메모리에서 빈 프레임에 넣는다. 이때 메모리에 빈 공간이 없다면 운영체제는 메모리 교체 정책에 따라 교체 대상 페이지(victim page)를 선택하여 디스크로 옮긴다.
3. 새롭게 적재한 프레임의 번호로 페이지 테이블 엔트리의 PFN을 갱신하고 valid 비트를 `1`로 설정한다.
4. CPU가 제어권을 넘겨받아 트랩을 발생시켰던 명령을 다시 실행한다.



## 페이지 교체 알고리즘

페이지 폴트가 발생하여 디스크의 SWAP 영역으로부터 페이지를 읽어 적재하려는데, 메모리에 빈 공간이 없다. 그렇다면 메모리에 있는 페이지를 SWAP 영역으로 내려 빈 공간을 만들어야한다. 이때 내보낼 페이지를 victim page라고 하며, victim page를 선택하기 위해 페이지 교체 알고리즘을 사용한다.

### OPT

**최적 페이지 교체 알고리즘(OPT; Optiomal Page Replacement)**는 앞으로 가장 사용하지 않을 페이지를 교체한다. 앞으로 페이지 폴트가 가장 적게 발생할 것이므로 이상적인 알고리즘이다. 그러나 운영체제는 페이지들이 미래에 언제 참조될지 알 수 없으므로 구현이 사실상 불가능하다.

### FIFO

**FIFO(First-In First-Out) 페이지 교체 알고리즘**은 메모리에 가장 먼저 적재된(적재된지 가장 오래된) 페이지를 교체한다. 운영체제는 페이지들을 연결 리스트로 구현하여 관리할 수 있다. 구현하기 간단하지만 자주 참조될 페이지를 내보내게 될 수도 있다.

### NRU

페이지 테이블 엔트리는 상태 비트로 reference bit와 modified bit를 유지한다. reference bit는 페이지가 최근의 클럭 틱 이후에 참조되었다는 것을 의미하며 modified bit는 페이지가 수정되었으며 디스크에 기록되어야할 필요가 있다는 것을 의미한다. 이 두 비트의 값에 따라 페이지들을 네 가지 클래스로 구분한다.

1. 클래스 0: reference bit 1, modified bit 1
2. 클래스 1: reference bit 0, modified bit 1
3. 클래스 2: reference bit 1, modified bit 0
4. 클래스 3: reference bit 0, modified bit 0

**NRU(Not Recently Used) 페이지 교체 알고리즘**은 클래스 0에 해당하는 페이지부터 교체한다. 이해하기 쉽고 효율적으로 구현할 수 있으며, 좋은 성능을 제공한다.

### LRU

**LRU(Least Recently Used) 페이지 교체 알고리즘**은 참조된지 가장 오래된 페이지를 교체한다. 최근에 자주 접근된 페이지들은 가까운 미래에도 자주 접근될 확률이 높다는 관찰에서 비롯한다. 미래를 예측하는 OPT와 달리 과거를 기반으로 예측하므로 구현이 가능하다. 실제로 사용 가능한 알고리즘 중 하나로 성능이 좋다.

페이지 테이블 엔트리의 reference bit는 클럭 틱 마다 클리어되므로 LRU를 지원하는 하드웨어 시스템은 많지 않다. 소프트웨어적으로 LRU는 **NFU(Not Frequently Used) 알고리즘**을 통해 지원된다. NFU는 참조된 횟수가 가장 적은 페이지를 교체한다.



## 페이지 교체 방식

멀티 프로그래밍에서는 어떤 프로세스의 페이지를 교체할 것인지가 중요하다.

### 지역 페이지 교체 알고리즘

**지역(local) 페이지 교체 알고리즘**은 페이지 폴트를 발생시킨 페이지가 속한 프로세스의 페이지를 교체한다.

### 전역 페이지 교체 알고리즘

**지역(global) 페이지 교체 알고리즘**은 페이지 폴트를 발생시킨 페이지가 어느 프로세스에 속하는지에 관계없이 페이지를 선택하여 교체한다.

프로세스의 실행에 따라 필요한 페이지 수가 변하는 경우라면 전역 알고리즘의 성능이 좋다. 지역 알고리즘을 사용하면 비어있는 페이지 프레임이 있어도 페이지가 교체되어 스레싱(thrashing)이 일어날 수 있기 때문이다. 스레싱은 페이지 폴트가 자주 발생하여 작업이 멈춘 것 같이 보이는 상태를 의미한다.



## 세그먼테이션

세그먼테이션(segmentation) 기법은 가변 분할 방식을 사용하는 가상 메모리 관리 기법이다. 프로세스는 자신의 크기만큼의 연속적인 물리 메모리를 할당받으며 이를 **세그먼트(segment)**라고 한다.

세그먼테이션에서는 가상 주소는 세그먼트를 구분하는 `세그먼트 번호`와 세그먼트의 시작 주소부터 해당 주소까지의 `거리`로 이루어진다. MMU는 **세그먼트 테이블(segment table)**을 사용하여 가상 주소를 물리 주소로 변환한다. 이때 주소를 변환하고 메모리 보호를 제공하는 방식이 base 레지스터와 limit 레지스터를 사용하는 방식과 동일하다. 세그먼트 테이블 엔트리는 limit과 address로 이루어지는데, limit은 세그먼트의 크기를 나타내고 address는 시작 주소를 나타낸다. MMU는 가상 주소에 address의 값을 더하고 이 값이 address와 address에 limit을 더한 값 사이에 있는지 검사한다. 만일 유효하지 않다면, 즉 프로세스가 자신의 주소 공간을 벗어나는 주소에 접근한다면 **세그먼테이션 폴트(segmentation fault)**를 발생시킨다.



## 페이징과 세그먼테이션의 비교

페이징 기법은 고정 분할 방식을 사용하므로 외부 단편화가 발생하지 않지만 내부 단편화가 생긴다는 단점이 있다. 또한 페이지 테이블의 엔트리가 페이지 하나를 가리키므로 테이블의 크기가 크다.

세그먼테이션 기법은 가변 분할 방식을 사용하므로 내부 단편화가 발생하지 않지만 외부 단편화가 생긴다는 치명적인 단점이 있다. 세그먼트 테이블의 엔트리가 세그먼트 하나를 가리키므로 테이블의 크기는 작다.

각 기법은 단점이 있으므로 순수하게 사용하기보다는 혼용하여 사용한다. 이를 세그먼테이션-페이징 기법이라고 한다.



## 세그먼테이션과 페이징 함께 사용하기

프로세의 수행 이미지는 코드, 데이터, 스택, 힙 영역으로 나누어진다. 세그먼테이션-페이징 기법에서는 하나의 프로세스 주소 공간이 여러 개의 세그먼트로 쪼개지고, 하나의 세그먼트가 다시 여러 개의 페이지로 쪼개진다. 이때 세그먼트는 프로세스의 수행 이미지를 이루는 코드(텍스트), 데이터, 스택, 힙에 해당한다. 코드 세그먼트는 특별히 라이브러리 세그먼트와 사용자 코드 세그먼트로 나누어진다.

TODO



## 참고

- 운영체제 강의 필기
- 운영체제론(노삼혁, 이동희 전흥석, 최종무 공역) 3장 메모리 관리
- [리눅스 커널: 메모리 관리](https://wiki.kldp.org/Translations/html/The_Linux_Kernel-KLDP/tlk3.html)
- [geeksforgeeks - Page Table Entries in Page Table](https://www.geeksforgeeks.org/page-table-entries-in-page-table/)
- [OS는 할껀데 핵심만 합니다. 14편 가상 메모리 개요, 페이징](https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-14%ED%8E%B8-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%9C%EC%9A%94-%ED%8E%98%EC%9D%B4%EC%A7%95#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)
- [OS는 할껀데 핵심만 합니다. 15편 가상 메모리, 세그먼테이션, 세그먼테이션-페이징 혼용 기법](https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-15%ED%8E%B8-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8E%98%EC%9D%B4%EC%A7%95-%ED%98%BC%EC%9A%A9-%EA%B8%B0%EB%B2%95)
- [OSTEP 18장 주소 변환의 원리](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/15-vm-mechanism.pdf)
- [OSTEP 21장 페이징: 개요](https://pages.cs.wisc.edu/~remzi/OSTEP/Korean/18-vm-paging.pdf)

