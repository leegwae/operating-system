# Process and Thread

## 프로세스

**프로세스(process)**는 RAM에 적재되어 실행 중인 프로그램을 의미하며 CPU의 작업 단위이다. 운영체제로부터 시스템 자원(CPU 시간, 주소 공간, 메모리 등)을 할당받는 주체이다.



## 프로세스 주소 공간

<img src="https://user-images.githubusercontent.com/57662010/209113874-1fef1053-383d-4403-9005-d9e994d550ad.png" alt="process address space" style="zoom: 67%;" />

**주소 공간(process address space)**은 프로세스가 사용할 수 있는 주소의 범위를 정의한 것으로 텍스트 세그먼트(text segment), 데이터 세그먼트(data segment), 스택 세그먼트(stack segment)로 나뉜다.

텍스트 세그먼트는 실행 가능한 코드나 상수, 변수와 같은 읽기 전용 데이터를 저장한다. 데이터 세그먼트는 전역 변수를 저장하며, 초기화되지 않은 전역 변수를 저장하는 GVAR 섹션과 초기화된 전역 변수를 저장하는 BSS 섹션으로 나뉜다. 스택 세그먼트는 함수와 관련한 데이터-매개변수, 리턴 주소, 지역 변수를 저장한다. 이들의 크기는 모두 컴파일에 결정된다. 스택과 데이터 사이의 빈 공간은 힙(heap)이라고 하며 동적 메모리를 할당할 때 사용한다. 힙의 크기는 런타임에 결정된다.



## 멀티 프로그래밍

다중 프로그래밍에서 하나의 CPU는 아주 짧은 주기로 프로세스를 번갈아 실행한다. 이때 다음에 실행할 프로세스를 선택하는 작업을 스케줄링이라고 하며, 실행 중인 프로세스를 선택된 프로세스로 바꾸는 작업을 문맥 교환이라고 한다.



### 문맥 교환

<img src="https://user-images.githubusercontent.com/57662010/209119490-2823a4e7-bcc2-4e91-b4dd-33fb9a41cbcb.png" alt="image" style="zoom:67%;" />

운영체제는 프로세스를 관리하기 위하여 각 프로세스를 실행하는데 필요한 정보를 담은 **PCB(process control block; 프로세스 제어 블록)**를 유지한다.

**문맥 교환(context switching)** 혹은 **프로세스 교환(process switching)**은 실행하던 프로세스의 정보를 PCB에 저장하고 실행하려는 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 것이다. 캐시를 플러시, 재적재하고 메모리 사상을 교체하는 등의 작업을 수행하므로 오버헤드가 발생한다.



### CPU-바운드 프로세스와 I/O-바운드 프로세스

버스트는 일정 시간 동안 계산이나 I/O를 수행하는 행위를 말한다. 전자를 CPU 버스트, 후자를 I/O 버스트라고 한다.

CPU-바운드 프로세스(computed-bound process)는 긴 CPU 버스트를 가지며 드물게 I/O를 기다리는 프로세스이다. I/O-바운드 프로세스는 짧은 CPU 버스트를 가지며 빈번하게 I/O를 기다리는 프로세스이다. 디스크에 비해 CPU가 빨라진 현대에서 프로세스는 대부분 I/O-바운드 프로세스로, CPU를 효율적으로 사용하기 위해서 멀티 프로그래밍을 적용하는 것이 적합하다. I/O-바운드 프로세스의 우선순위를 더 높게 주어 이들이 I/O를 기다리는 동안 CPU-바운드 프로세스를 실행하면 된다. 



### 프로세스 상태

<img src="https://user-images.githubusercontent.com/57662010/209124816-fae17edf-882e-43e0-8dd9-a882840f4e62.jpg" alt="Process-state" style="zoom:67%;" />

- new: 프로세스를 생성 중이다.
- ready: 실행 가능하며, 실행되기를 기다린다.
- running: 현재 실행 중이다. 스케줄러에 의해 ready 상태의 프로세스가 선택되어 실행된다.
- waiting(blocked): 특정 이벤트가 발생하기 전까지 실행할 수 없다. 특정 이벤트가 발생하기를 기다린다. 예를 들어 프로세스는 사용자의 입력을 기다리거나 디스크에서 파일을 읽어오는 동안 멈출 수 있다.
- terminated: 프로세스가 모든 자원을 반납하고 종료되었다.
- suspended: swap out되어 프로세스의 수행이 정지되었다. 



## 프로세스 스케줄링

### 스케줄링 큐의 종류

각각의 프로세스(PCB)는 상태에 따라 큐에 입력된다. Job Queue는 시스템에 존재하는 모든 프로세스를 저장한다. Ready Queue는 메모리 내에 적재되어 실행되기를 기다리는 프로세스를 저장한다. Device Queue는 I/O 장치의 입출력을 기다리는 프로세스를 저장한다.



### 장기, 중기, 단기 스케줄러

**Long-term scheduler(job scheduler)**는 어떤 프로세스를 ready queue로 보낼지 결정한다. **Short-term scheduler(CPU scheduler)**는 어떤 프로세스를 다음에 실행할지 결정한다. **Medium-term scheduler(swapper)**는 메모리에 적재된 프로세스를 조절하여 여유 공간을 확보한다. swapper는 메모리에 적재된 프로세스의 수행 이미지를 디스크의 swap 영역에 기록(swap out)하거나 swap 영역으로부터 읽어들여 메모리에 적재(swap in)한다.



### 선점, 비선점 스케줄링 알고리즘

**선점형(preemptive) 스케줄링 알고리즘**의 경우 운영체제는 현재 실행 중인 프로세스의 CPU 자원을 빼앗아 다른 프로세스에게 할당할 수 있다. 문맥 교환으로 인한 오버헤드가 발생하거나, 우선순위가 높은 프로세스에게 CPU 자원이 계속 할당되어 어떤 프로세스가 기아 상태에 빠질 수 있다. 응답 시간이 빠르고 CPU가 효율적으로 사용된다는 장점이 있다. 대화형 시스템에 적합하다.

**비선점(nonpreemptive) 스케줄링 알고리즘**의 경우 현재 실행 중인 프로세스는 waiting이나 terminated 상태가 되기 전까지 CPU 자원을 독점한다. 버스트 시간이 긴 프로세스에게 CPU 자원이 할당되면 버스트 시간이 짧은 프로세스는 기아 상태에 빠질 수 있다. 또한 응답 시간이 느리며, CPU가 효율적으로 사용되지 못한다는 단점이 있다. 배치 시스템에 적합하다.



### 배치, 대화식, 실시간 시스템

**배치 시스템**은 프로그램을 요청 순서에 따라 순차적으로 처리한다. 빠른 응답을 필요로 하지 않으므로 비선점이나 주기가 긴 선점형 알고리즘이 적절하다. 문맥교환을 줄여 성능을 향상시키는 기법이다. **대화식 시스템**은 여러 개의 프로세스를 번갈아 실행한다. 다수의 사용자에게 빠르게 응답하는 것이 중요하므로 한 프로세스가 CPU를 독점하지 않도록 선점형 알고리즘을 사용한다. **실시간 시스템**은 데드라인 안에 응답하는 것이 중요하다.



### 비선점 스케줄링

#### FCFS

**FCFS(First-come First-served)**에서는 프로세스들이 요청한 순서대로 큐에 삽입되고 CPU를 할당받는다. 수행 시간이 짧은 프로세스가 뒤로 갈수록 평균 반환 시간(대기 시간 + 실행시간)이 증가한다.

#### SJF

**SJF(Shortest Job First)**에서는 수행 시간이 짧은 프로세스가 먼저 실행된다. 평균 대기 시간이 가장 짧지만,  프로세스의 수행 시간은 미리 알기 어렵다.

#### HRRN

**HRRN(Highest Response Ratio Next)**에서는 response ratio가 높은 순서대로 프로세스를 실행하여 기아 문제를 해결한다.

````
response ratio = (대기 시간 + 수행 시간) / (수행 시간)
````

#### Priority Scheduling

**우선순위 스케줄링(Priority Scheduling)**에서는 우선순위가 높은 프로세스부터 실행된다. 우선순위가 낮은 프로세스가 기아 상태에 빠질 수 있다.



### 선점 스케줄링

#### SRTN

**SRTN(Shrotest Remaning Time Next)**는 SJF의 선점 구현으로 새로운 프로세스가 현재 실행 중인 프로세스보다 수행 시간이 짧다면 먼저 실행된다. 수행 시간이 긴 프로세스가 기아 상태에 빠질 수 있다.

#### Round-Robin Scheduling

**라운드 로빈 스케줄링(Round-Robin Scheduling)**에서는 프로세스는 동일한 할당 시간(time quantumn)만큼 번갈아가며 실행한다. 할당 시간을 모두 사용하면 프로세스는 ready 상태가 된다. 할당 시간을 크게 하면 뒤쪽 순서의 프로세스가 대기하는 시간이 늘어나며, 작게 하면 응답은 빠르지만 문맥 교환으로 인한 오버헤드가 증가한다.

#### Multi Level Queue Scheduling

**다단계 큐(Multi Level Queue Scheduling)**는 우선순위가 같은 프로세스를 하나의 큐에 넣고 각 큐는 라운드 로빈이나 FCFS 등 독자적인 스케줄링을 가진다. 우선순위가 높은 큐의 할당 시간은 짧게, 우선순위가 낮은 큐의 할당 시간은 길게 할당한다. 더 높은 우선순위의 큐가 비면 낮은 우선순위의 큐를 작업하므로 기아 문제가 발생할 수 있다. 

#### Multi Level Feedback Queue Scheduling

**다단계 피드백 큐(Multi Level Feedback Queue Scheduling)**는 다단계 큐를 사용하는데 I/O 버스트 프로세스에게 더 높은 우선순위를 부여한다. 할당 시간을 모두 소요한 프로세스는 한 단계 낮은 우선순위를 부여받게 된다. 기다린 시간에 따라 우선순위가 높아지는 에이징 기법을 적용하여 기아 문제를 예방할 수 있다. 응답 시간이 빠르고 반환 시간이 짧다. 



(2022.12.22)

***

## 멀티 프로세스

**멀티 프로세스(multi process)**는 여러 개의 CPU로 하나 이상의 프로세스를 병렬적으로 처리하는 것을 의미한다. 각각의 프로세스는 독립적으로 자원을 할당받으므로 하나의 프로세스가 종료되어도 다른 프로세스에게 영향을 끼치지 않는다는 장점이 있다. 그러나 각각 자원을 할당해야한다는 점에서 자원 소모가 크며, 문맥 교환이 잦다면 오버헤드가 발생한다. 또한 프로세스는 서로의 자원에 접근하기 위하여 복잡하고 어려운 **IPC(inter-process communication; 프로세스 간 통신)** 기법을 사용해야 한다.

***

## 스레드

**스레드(thread)**는 프로세스 내에 있는 여러 개의 실행의 흐름을 일컫는 단위이다. 프로세스는 한 개 이상의 스레드를 가지게 된다. 같은 프로세스 내에 있는 스레드들은 프로세스가 할당받은 자원을 공유하나, 각각의 스레드는 독립적으로 함수를 호출하므로 스택은 독립적으로 할당받는다. 스레드의 문맥교환을 위하여 스레드 테이블(thread table)을 유지하는데, 사용자 수준(user-level) 스레드의 경우 각각의 프로세스가 스레드 테이블을 가지며 커널 수준 스레드의 경우 운영체제가 프로세스 테이블과 스레드 테이블을 가지고 스레드 단위로 스케줄링한다.



### 멀티 스레드

**멀티 스레드(multi thread)**는 하나의 프로세스가 여러 개의 스레드로 구성되어, 하나의 스레드가 하나의 작업을 처리하는 것을 말한다. 스레드는 자원을 공유하므로 자원 소모가 적으며 데이터 영역 혹은 힙 영역을 사용하여 데이터를 주고받을 수 있어 스레드 간의 통신이 간단하다. 또한 스레드의 문맥 교환은 캐시를 초기화하지 않아도 되므로 비용이 적다. 그러나 하나의 스레드에 이상이 있으면 프로세스 자체가 죽어버릴 수도 있다(다른 스레드 모두 종료될 수 있다). 또한 자원을 공유하므로 **임계 영역(critical section)**에 대해 **동기화 작업**을 필요로 한다.



## 프로세스와 스레드의 차이

각각의 프로세스는 독립적이어서 서로의 자원에 접근할 수 없다. 따라서 서로의 자원에 접근하기 위해 IPC를 사용해야 한다. 그러나 스레드는 한 프로세스 안에 있다면 스택을 제외하고 프로세스가 할당받은 자원을 공유한다. 그래서 데이터 영역과 힙 영역으로 데이터를 주고 받을 수 있다.



## 멀티 스레드를 사용하는 이유

프로세스는 자원을 독립적으로 할당받으므로 시스템 자원을 그만큼 소모해야 하며, 문맥 교환 비용이 크다. 서로의 자원에 접근하기 위한 프로세스 간 통신도 어렵다. 그러나 스레드는 프로세스가 할당받은 자원을 공유하므로 자원을 덜 소모하며, 문맥 교환 비용도 더 적다. 데이터 영역이나 힙 영역을 공유하므로 스레드 간 통신이 쉽다.