# Process Synchronization

프로세스 동기화(process synchronization)는 공유 데이터가 프로세스의 접근 순서에 상관없이 일관성을 유지하도록 하는 것이다.



## 경쟁 상태

**경쟁 상태(race condition)**는 공유 자원에 두 개 이상의 프로세스가 접근할 때 그 접근 순서에 따라 결과가 달라지는 상황을 뜻한다. **임계구역(critical section)**은 공유 자원에 접근하는 코드 영역을 의미한다. 즉, 임계구역에서 경쟁 상태가 발생한다.

임계구역 문제를 바람직하게 해결하려면 세 가지 조건을 충족해야한다. 첫번째, 두 프로세스가 동시에 임계구역에 존재하지 않아야한다. 이를 **상호배제(mutual exclusion)**라고 하며, 한 프로세스가 임계구역에 진입하여 공유 메모리를 읽고 쓸 동안 다른 프로세스는 그러지 못하게 막아 구현한다. 두번째, 임계구역 외부에서 실행되고 있는 프로세스가 다른 프로세스의 진입을 막으면 안된다(임계구역이 비어있으면 진입할 수 있어야 한다). 이를 **진행(progress)**이라고 한다. 두번째, 프로세스는 언젠가는 임계구역에 진입할 수 있어야 한다. 이를 **한정된 대기(bounded waiting)**라고 한다. 

상호배제만으로도 경쟁 상태를 피할 수 있으나, 병렬 프로세스에서 발생하는 다른 문제들을 해결하기 위해서 나머지 두 조건도 필요로 한다.



## 생산자-소비자 문제

```
// 생산자 프로세스
버퍼에 넣기;
count = count + 1;	// 임계구역
```

```
// 소비자 프로세스
버퍼에서 빼기;
count = count - 1;	// 임계구역
```

`생산자` 프로세스와 `소비자` 프로세스는 고정 크기의 버퍼를 공유한다. `생산자`는 맨 앞에서부터 정보를 저장하고, `소비자`는 맨 뒤에서부터 정보를 꺼낸다. 이때 버퍼에 들어있는 데이터의 개수를 나타내는 `count`가 임계구역이 된다. 만일 소비자나 생산자가 버퍼를 건드린 후 `count`를 갱신하지 못한 채 상대 프로세스로 문맥교환된다면 경쟁 상태가 발생할 수 있다.

1. `count`가 3이다.
2. 생산자가 버퍼에 아이템을 추가한다. `count`를 증가시키기 전 소비자로 문맥교환된다.
3. 소비자가 버퍼에서 아이템을 꺼낸다. 

두 가지 경우가 생긴다.

1. 생산자로 문맥교환될 경우: 생산자는 `count`에 4를 할당한다. 그 후 소비자로 문맥교환되는데 소비자는 `count`에 2를 할당한다.
2. 소비자가 계속 실행될 경우: 소비자는 `count`에 2를 할당한다. 그 후 생산자로 문맥교환되는데 생산자는 `count`에 4를 할당한다.



## 임계구역 문제 해결하기

바쁜 대기(busy waiting)는 변수가 특정 값이 될 때까지 계속 검사하는 것이다.

바쁜 대기를 사용하여 임계구역 문제를 해결하는 방법을 알아본다.

### 인터럽트 끄기

프로세스가 임계구역에 진입하면 인터럽트를 꺼서 문맥 교환이 일어나지 않도록 하고 임계구역에서 나가기 적전에 인터럽트를 켠다. 그러나 인터럽트를 끄고 켜는 것은 커널의 고유 권한이다. 또한 프로세스가 인터럽트를 건다면 자신을 실행하는 CPU에만 영향을 끼치므로 CPU가 여러 개인 멀티 환경에서는 유효하지 않은 방법이다.

### 락 변수 사용하기

스핀 락(spin lock)은 바쁜 대기를 사용하는 락이다. 프로세스는 하나 혹은 두 개의 공유 락 변수를 사용할 수 있다. 

### 하나의 공유 락 변수 사용하기

```
while (lock == 1);
lock = 1;
임계구역;
lock = 0;
```

프로세스는 공유 락 변수를 확인하여 `0`이면 공유 락을 `1`로 설정하고 임계구역에 진입한다. 임계구역을 수행한 후 나올 때 공유 락을 `0`을 설정해준다. 다른 프로세스는 공유 락 변수가 `1`이므로 `0`이 될 때까지 기다린다. 그런데 다음과 같은 경우를 생각해보자. `A` 프로세스가 임계구역에 진입하기 위해 락을 걸기 직전, 다른 프로세스 `B`가 스케줄되어 락을 건다. 그리고 다시 스케줄된 `A`가 락을 건다면 임계구역에는 `A`와 `B`가 동시에 존재하게 된다. 이것은 첫번째 조건인 상호 배제를 위반한다.

### 두 개의 공유 락 변수 사용하기

```
// 프로세스 A
lock1 = true;
while (lock2 == true);
임계구역;
lock1 = false;
```

```
// 프로세스 B
lock2 = true;
while (lock1 == true);
임계구역;
lock2 = false;
```

각각의 프로세스는 자신의 락을 건 후 상대방이 락을 풀 때까지 대기한다. 임계구역에 진입하고 나올 때 자신의 락을 푼다. 그런데 다음과 같은 경우를 생각해보자. 프로세스 `A`가 락을 건 후 문맥 교환이 일어나 프로세스 `B`가 실행되었다. 프로세스 `B` 역시 락을 걸었고 다시 문맥 교환이 일어나 프로세스 `A`가 실행된다. 이때 프로세스 `A`와 프로세스 `B`는 모두 락을 건 상태이고 임계구역은 비어있다. 프로세스 `A`는 `B`가 락을 걸었으므로 대기하고, 할당된 CPU 시간을 다 써 프로세스 `B`로 스케줄링된다. 프로세스 `B`는 프로세스 `A`가 락을 걸었으므로 대기하고, 할당된 CPU 시간을 다 써 프로세스 `A`로 스케줄링된다. 이것은 두번째 조건인 한계 대기를 위반하며, 두 프로세스 모두 무한한 대기에 머무르는 교착 상태(데드락; deadlock)에 빠지게 된다.

### 엄격한 교대

```
// 프로세스 A: lock이 0이 될 때까지 대기
while (TRUE) {
	while (lock != 0);
	임계구역;
	lock = 1;
	비임계구역;
}
```

````
// 프로세스 B: lock이 1이 될 때까지 대기
while (TRUE) {
	while (lock != 1);
	임계구역;
	lock = 0;
	비임계구역;
}
````

두 프로세스는 각자 `0`과 `1`이라는 값을 가지고 공유 락 변수가 해당 값이 될 때까지 기다린다. 락 값이 자신의 값이 된다면 임계구역을 수행하고 락을 다른 프로세스의 값으로 설정하고 비임계구역을 수행한다.

그러나 다음과 같은 경우를 생각해보자. 프로세스 `A`는 임계구역을 떠나며 락을 `1`로 설정했다. 프로세스 `B`는 락이 `1`로 설정되었으니 재빨리 임계구역에 진입하여 일을 처리한 후 락을 `0`으로 설정하고 비임계구역을 수행한다. 이때 락은 `0`이고 두 프로세스 모두 비임계구역에 있다. 비임계구역 수행을 마친 `A`는 락이 `0`이 되었으므로 임계구역을 수행한다. 이후 임계구역을 떠나며 락을 `1`로 설정하고 비임계구역을 수행한다. 이때 락은 `1`이고 두 프로세스는 비임계구역에 있다. 그런데 `A`의 수행 속도가 빨라, 비임계구역의 일을 마치고 다시 락이 `0`이 되기를 기다린다. 즉, 프로세스의 수행 속도가 느리다면 다른 프로세스는 계속 기다려야한다. 이 경우 비임계구역의 프로세스 `B`가 `A`의 임계구역 진입을 막고 있다. 이것은 세번째 조건인 진행을 위반한다. 또한 바쁜 대기의 특성상 프로세스가 계속 값을 검사하며 기다리므로 CPU 시간이 낭비된다.

### sleep-wakeup 연산자

바쁜 대기는 CPU 시간을 낭비한다. sleep-wakeup 연산자는 블로킹을 사용하여 이 문제를 해결한다. `sleep` 연산자는 호출자를 블록 상태로 만들어 다른 프로세스가 호출자를 깨울 때까지 블로킹된다. `wakeup` 연산자는 인자로 전달된 프로세스를 깨운다.

### sleep-wakeup 연산자와 생산자-소비자 문제

```C
#define N 100
int count = 0;

void 생산자(void){
    int item;
    
    while (TRUE) {
        item = produce_item();
        if (count == N) sleep();
        insert_item(item);
        count += 1;
        if (count == 1) wakeup(consumer);
    }
}

void 소비자(void){
    int item;
    
    while (TRUE) {
        if (count == 0) sleep();
        item = remove_item();
        count -= 1;
        if (count == N - 1) wakeup(consumer);
        consume_item(item);
    }
}
```

`생산자`는 버퍼가 꽉 차면 잠들고 `소비자`는 버퍼가 텅 비면 잠든다. `소비자`가 데이터를 하나 꺼내 버퍼에 빈 공간이 생기면 생산자를 깨우고 `생산자`는 데이터를 하나 만들어 버퍼에 데이터가 한 개 있으면 소비자를 깨운다.

그런데 버퍼의 데이터 개수를 저장하는 변수 `count`에 경쟁 상태가 발생할 수 있다. 버퍼가 비고 소비자는 개수가 `0`임을 알았다(`if (count ==0)`). 이때 스케줄러가 소비자를 중지시키고 생산자를 실행하는데, 생산자는 데이터를 버퍼에 추가하고 개수를 `1`로 증가시킨다. 개수가 `1`이므로 생산자는 소비자를 깨운다. 그리고 스케줄러가 생산자를 중지시키고 소비자를 실행하는데, 소비자는 개수가 `0`이라고 알고 있으므로 잠들게 된다. 다시 스케줄러에 의해 생산자가 실행되고 생산자는 버퍼를 꽉 채운 후 잠든다. 생산자와 소비자는 영원히 잠들게 되어 교착 상태에 빠진다.

이렇게 '깨움이 소실되는' 문제는 프로세스가 버퍼에 데이터 개수를 저장하는 변수를 확인하고, 조건에 부합하면 잠들기까지의 두 연산이 원자적(atomic)이지 않기 때문이다. 소비자가 `0`임을 확인하고 잠들기까지(`if (count ==0) sleep()`)가 하나의 연산처럼 원자적으로 이루어져야 하나, 중간에 생산자가 스케줄링되어 문제가 발생하는 것이다.



## 원자적 연산

원자적 연산은 CPU 레벨에서 지원하여  실행 중간에 간섭받거나 중단되지 않으며, 같은 메모리 영역에 대해 동시에 실행되지 않는다.

어떻게 원자적 연산을 구현할 수 있을까? 커널이 제공하는 세마포어, 뮤텍스, 모니터를 사용한다면 원자적 연산을 구현할 수 있다. 

### 세마포어

다익스트라는 sleep과 wakeup 연산자가 일반화된 down과 up 연산을 제안한다.

```c
struct semaphore {
	int count;			// wake up 개수, 사용 가능한 자원의 개수를 의미한다.
	queueType queue;
}

void down(semaphore s)
{
    // 사용 가능한 자원이 있다면
	if (s.count > 0) s.count -= 1; // 자원을 하나 사용한다.
	else {
		프로세스를 s.queue에 넣는다;	// 사용할 수 있는 자원이 없다면 프로세스가 잠든다.
	}
}

void up(semaphore s) {
    s.count += 1; // 사용했던 자원을 하나 반납한다.
    // 세마포어 s에 잠들어있는 프로세스가 하나 이상이라면
	if (s.queue에 프로세스가 있다면) {
		프로세스 하나를 s.queue에서 꺼낸다;	// 프로세스를 깨운다.
		깨운 프로세스를 레디 큐로 보낸다;
	}
}
```

세마포어(semaphore)는 `down`과 `up` 연산자를 사용한다. 이 두 연산자는 원자적 연산으로, 연산이 완료되거나 프로세스가 잠들기 전까지 다른 프로세스가 세마포어에 접근할 수 없도록 보장한다. `down` 연산은 세마포어의 값이 0보다 크다면 값을 감소시키고 임계구역에 진입하지만 값이 0이라면 그 즉시 프로세스는 잠들게 된다. `up` 연산은 값을 증가시키는데, 잠들어있는 프로세스가 있다면 시스템이 그 중 하나를 선택하여 깨운다. wake up 신호를 받아 깨어난 프로세스는 `down` 연산의 수행을 완료할 수 있다.

이진 세마포어(binary semaphore)는 두 개의 값을 가지며, 카운팅 세마포어(couting semaphore)는 그 이상의 값을 가진다.

세마포어 연산은 원자적이므로 깨움이 소실되는 문제는 해결하며, 바쁜 대기를 하지 않고 블로킹을 사용하여 효율적이지만 일반적으로 시스템 콜의 형태로 구현되어 오버헤드가 있다.

### 세마포어와 생산자-소비자 문제

```c
#define N 100			// 버퍼 크기
typedef int semaphore;
semaphore guard = 1;	// 임계구역에 진입할 때 사용
semaphore empmty = N;	// 남아있는 버퍼 크기
semaphore full = 0;		// 사용한 버퍼 크기

void producer(void) {
	int item;
    
    while (TRUE) {
        item = product_item();
        down(&empty);
        down(&guard);
        insert_item(item);
        up(&guard);
        up(&full);
    }
}

void consumer(void) {
    int item;
    
    while (TRUE) {
        down(&full);
        down(&guard);
        item = remove_item();
        up(&guard);
        up(&empty);
        consume_item(item);
    }
}
```

이 문제에서 임계 구역은 버퍼가 된다. `guard` 세마포어는 임계구역인 버퍼에 대한 상호 배제를 위해 사용되었다. `empty` 세마포어와 `full` 세마포어는 동기화 문제를 해결하기 위해 사용되었다.

생산자는 아이템을 버퍼에 넣기 전 남아있는 버퍼 크기를 나타내는 `empty` 세마포어와 임계구역에 다른 프로세스가 진입해있는지 나타내는 `guard` 세마포어에 대해 차례로 `down` 연산을 실행한다. `empty` 세마포어에서 잠든다면 그것은 버퍼가 꽉 찼다는 뜻이므로 소비자가 `empty` 세마포어에 대하여 `up` 연산을 실행하면 깨어난다. 이후 `guard` 세마포어에 `down` 연산을 실행하여 임계구역에 락을 건다. 임계구역에 진입한 생산자는 버퍼에 아이템을 하나 넣고 임계구역을 빠져나온다. `guard`를 `up`하여 소비자가 임계구역에 진입할 수 있도록 락을 풀고, `full`를 `up`하여 잠들어있는 소비자를 깨워준다.

소비자는 `full` 세마포어와 `guard` 세마포어에 대하여 차례로 `down` 연산을 실행한다. `full` 세마포어에서 잠든다면 그것은 버퍼가 비어있다는 뜻이므로 생산자가 `full` 세마포어에 대하여 `up` 연산을 실행하면 깨어난다. 이후 `guard` 세마포어에 `down` 연산을 실행하여 임계구역에 락을 건다. 임계구역에 진입한 소비자는 버퍼에서 아이템을 하나 꺼내고 임계구역을 빠져나온다. `guard`를 `up`하여 생산자가 임계구역에 진입할 수 있도록 락을 풀고, `empty`를 `up`하여 잠들어있는 생산자를 깨워준다.

### 이진 세마포어

위 생산자 소비자 문제에서 사용된 `guard` 세마포어는 0(언락)과 1(락)이라는 두 개의 값을 가지므로 이진 세마포어이다. 이진 세마포어는 세마포어로 공유 자원이나 임계구역에 대하여 상호 배제를 구현할 때 사용한다. `wait`과 `signal` 연산을 가지는데 세마포어의 `down`과 `up` 연산과 내부 구현이 동일하다.

### 뮤텍스 락

```c
mutex->lock();
임계구역;
mutext->unlock();
```

**뮤텍스(mutex)**는 상호 배제(**mut**ual **ex**clusion)의 약자로, 스레드 간 공유 자원이나 임계구역에 대해 상호 배제를 할 때 사용한다. 리눅스 커널의 사용자 레벨 스레드 패키지에서 `mutex_lock` 연산과 `mutex_unlock` 연산을 지원한다.

스레드는 임계구역에 진입하기 전 `mutex_lock`을 호출한다. 언락 상태라면 락을 거는데 성공하고 임계구역에 진입한다. 락 상태라면 락이 해제되기 전까지, 즉 임계구역에 있는 스레드가 임계구역을 벗어날 때 `mutex_unlock`을 호출할 때까지 블록된다. 락이 해제될 때 뮤텍스에 하나 이상의 스레드가 블록되어있다면 임의의 스레드가 선택되어 락을 획득한다. 따라서 한 시점에서 뮤텍스를 소유할 수 있는 스레드는 단 하나이며, 소유자만이 자신이 소유한 스레드의 락을 해제할 수 있다.

한편 `mutex_lock`는 락을 획득하지 못하면 `thread_yield`를 호출하여 다른 스레드에게 CPU를 넘긴다. 이 `thread_yield`는 사용자 공간의 스레드 스케줄러를 호출하므로 뮤텍스는 커널을 호출하지 않아 매우 빠르다.

### 뮤텍스와 세마포어의 차이

세마포어는 정수 변수이다. 이 정수 변수는 사용할 수 있는 자원의 개수를 의미한다. 세마포어는 signaling 메커니즘에 기반하여, 자원을 사용하고 싶은 프로세스나 스레드는 자원이 없다면 세마포어에서 잠들고 다른 프로세스나 스레드의 wake up 신호에 의해 깨어난다. (우선순위가 더 높은 프로세스나 스레드가 잠들어있는 프로세스/스레드를 깨울 수도 있다.) 그러므로 세마포어는 하나의 프로세스/스레드에게 독점되는 것이 아니며, 여러 개의 프로세스와 스레드가 동일한 세마포어를 획득한다. 달리 말하여 여러 개의 프로세스/스레드가 세마포어의 값을 변경할 수 있는데, 다만 한 번에 하나의 프로세스/스레드만이 변경할 수 있다. 세마포어의 특성상 자원의 인스턴스 수가 여러 개라면 세마포어를 사용하는 것이 적합하다.

뮤텍스는 객체이다. 이 객체는 멀티스레드 환경에서 임계구역에 대한 사용권을 획득하고 다른 스레드의 진입을 방지하기 위해 사용한다. 뮤텍스는 locking 메커니즘에 기반하여, 임계구역에 진입하려는 스레드가 뮤텍스에 대해 락을 걸고 뮤텍스를 소유한다. 그러므로 뮤텍스는 한 번에 하나의 스레드에게 독점되고(하나의 스레드에 의해서 락이 걸리고) 해당 스레드에 의해 락이 해제될 수 있다. 이때 락의 해제는 스레드가 임계영역에서 나갈 때만 가능하다. 뮤텍스의 특성상 자원의 인스턴스가 한 개라면 뮤텍스를 사용하는 것이 적합하다.



## 식사하는 철학자 문제

다섯 명의 철학자가 원형 식탁에 앉아있다. 각각의 철학자 앞에는 파스타가 놓여있는데 파스타를 먹으려면 접시 양쪽에 놓인 두 개의 포크가 필요하다. 식사를 하기 위해 철학자는 왼쪽 포크를 먼저 집고 오른쪽 포크를 집거나, 오른쪽 포크를 먼저 집고 왼쪽 포크를 집는다. 철학자들이 하는 일을 중단하지 않는 프로그램을 작성할 수 있을까?

1. 한쪽의 포크를 잡은 후 다른 쪽 포크를 잡을 때까지 기다린다고 하자. 그러나 다섯 명의 철학자가 동시에 왼쪽 포크를 잡으면 모두 오른쪽 포크를 집을 때까지 기다리므로 교착 상태가 발생할 수 있다.
2. 한쪽의 포크를 잡은 후 다른 쪽 포크를 잡을 수 있는지 검사한다. 그렇지 않다면 내려놓고 이 과정을 반복한다. 그러나 다섯 명의 철학자가 동시에 왼쪽 포크를 잡는다면 오른쪽 포크를 사용할 수 없어 내려놓게 될 것이고, 다시 왼쪽 포크를 잡는 과정을 영원히 반복하여 잠들지는 않는 경우가 발생할 수 있다. 이때 프로세스들은 잠들지 않고 계속 실행되지만, 어떠한 진전도 없는 **기아(starvation)** 상태가 발생할 수 있다.

### 세마포어 사용하기

포크가 임계구역이므로, 포크를 집을 때와 내려놓을 때 이진 세마포어를 사용해볼 수 있을 것이다.

```c
#define N 		5
#define LEFT	(i + N - 1) % N
#define RIGHT	(i + 1) % N
#define THNKING	0
#define HUNGRY	1
#define EATING	2
typedef int semaphore;
int state[N];
semaphore mutex = 1;
semaphore s[N];

void philosopher(int i)
{
    while (TRUE) {
        think();
        take_forks();
        eat();
        put_forks();
    }
}

void take_forks(int i)
{
    down(&mutex);
    state[i] = HUNGRY;
    test(i);
    up(&mutex);
    down(&s[i]);
}

void put_forks(i)
{
    down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(i)
{
    if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

-> TODO 주석 달기

## 우선순위 역전

**우선순위 역전(Priority Inversion) 문제**는 공유 데이터 동기화에서 우선순위가 높은 프로세스가 낮은 프로세스에 의해 수행이 지연되는 문제를 말한다. 주로 우선순위 기반 선점형 스케줄링을 사용하는 RTOS(Real Time Operating System)에서 발생한다.

우선순위대로 나열한 프로세스 T1, T2, T3가 있다.

1. T1, T2가 준비 상태가 아니므로 T3이 실행된다. T3은 공유 자원에 lock을 건다.
2. T1이 준비 상태가 되고 T1으로 문맥 교환된다.
3. T1은 공유 변수가 lock이 걸려있으므로 블록된다.
4. T3이 실행되다가 T2가 준비 상태가 되어 T2로 문맥 교환한다.
5. T2가 실행을 마치고 T3으로 문맥 교환된다. 공유 변수를 unlock한다.
6. T1이 실행된다.

T1은 가장 우선순위가 높지만 가장 나중에 실행되고 있다.

### 우선순위 상속

T3이 먼저 실행된 이상, T1이 실행되기 위해서는 반드시 T3의 실행이 완료되어 락이 해제되어야한다. 이때의 최선은 T3, T1, T2 순으로 실행되는 것이다. 따라서 T1에 T3에게 우선순위를 상속하도록 한다. T3은 실행을 마치고 unlock하여 T1이 실행된다. 마지막으로 T2가 실행된다. 



## 정리

1. 세마포어란 무엇인가

   세마포어는 프로세스나 스레드 간 동기화를 위해 사용한다. 자원의 가용 개수를 나타내는 정수 변수를 값으로 가진다. down(wait) 연산으로 이 값을 감소시키고 up(signal) 연산으로 값을 증가시키는데, 원자적 연산이므로 연산이 완료되기 전까지 다른 프로세스가 세마포어에 접근할 수 없도록 보장한다. 따라서 한 번에 하나의 프로세스(스레드)만이 값의 변경을 수행할 수 있다.

   자원을 사용하려는 프로세스가 down을 호출하면, 사용가능한 자원이 없는 경우 down을 완료하지 못하고 세마포어에서 잠든다. 프로세스가 up을 호출하면 세마포어에 하나 이상의 프로세스가 잠들어있는 경우 이들 중 하나가 선택되어 깨어나고, down 연산을 수행하게 된다.

2. 뮤텍스란 무엇인가

   뮤텍스는 멀티 스레드에서 공유 자원이나 임계구역에 대해 상호배제를 하기 위해 사용한다. 임계구역에 스레드가 진입해있다면 락, 그렇지 않다면 언락의 상태를 가진다. 스레드는 임계구역에 진입할 때 뮤텍스에 락을 걸고 나올 때 락을 해제한다. 락을 걸지 못한 스레드는 CPU를 다른 스레드에게 양보하고 뮤텍스에서 블록된다. 뮤텍스를 소유했던 스레드가 락을 해제할 때 해당 뮤텍스에 잠들었던 스레드 중 하나가 선택되어 락을 걸고 임계구역에 진입한다.

3. 뮤텍스와 스핀락의 차이는 무엇인가?

   첫번째, 뮤텍스에서 스레드는 락을 획득할 수 없으면 블록된다. 그러나 스핀록에서 스레드(프로세스)는 락을 얻을 때까지 루프를 돌며 기다린다. 두번째, 뮤텍스의 경우 락을 획득하지 못하면 CPU를 다른 스레드에게 양보한다. 즉, 문맥 교환을 사용한다. 그러나 스핀록은 계속 대기를 하며 CPU를 사용하므로 문맥 교환을 사용하지 않는다. 세번째, 이러한 특성상 뮤텍스는 자원을 획득하기 위해 긴 시간이 필요한 경우 비교적 유리하다. 자원을 획득할 때까지 해당 스레드는 블록하고 CPU가 다른 작업의 스레드를 수행할 수 있기 때문이다. 이와 달리 스핀록은 자원을 획득하기까지 짧은 시간이 필요한 경우 비교적 유리하다. 문맥 교환에 관련한 비용을 지불하지 않기 때문이다.

4. 뮤텍스와 세마포어의 차이는 무엇인가?

   첫번째, 뮤텍스는 단일한 자원을 대상으로 하고 세마포어는 여러 개의 인스턴스를 대상으로 한다. 뮤텍스의 값은 자원이 사용되고 있는지 상태를 나타내는 락과 언락이다. 세마포어의 값은 정수 변수로 자원의 가용 개수, 곧 자원에 접근할 수 있는 최대 프로세스(스레드) 개수를 나타낸다. 두번째, 뮤텍스는 locking 메커니즘을 사용하고 세마포어는 signaling 메커니즘을 사용한다. 뮤텍스에서는 자원을 사용하려는 스레드가 자원에 락을 걸고 사용한 후, 락을 해제한다. 세마포어는 wait 연산과 signal 연산으로 세마포어의 값을 변경하여 프로세스가 자원을 사용하고 있는지 표시한다. 세번째, 한 번의 하나의 스레드만이 뮤텍스를 획득할 수 있으나, 세마포어의 경우 여러 프로세스가 동시에 동일한 세마포어를 획득할 수 있다. 네번째, 뮤텍스에 걸린 락을 해제하는 것은 해당 뮤텍스를 획득한 스레드만이 가능하나 세마포어의 경우 세마포어를 획득하지 않은 스레드가 세마포어에 걸린 락을 해제할 수도 있다. 

5. 모니터에 대하여 말해보세요

   모니터는 프로세스 동기화 기법 중 하나로 프로시저, 변수, 자료구조가 모인 모듈이다(즉 프로그래밍 언어가 지원해야한다). 모니터 외부의 프로세스는 모니터 내부의 자료구조에 직접 접근할 수 없다. 한 번의 하나의 프로세스만 모니터의 프로시저를 호출할 수 있다. 다른 프로세스가 모니터에서 활동 중이라면 호출한 프로세스는 모니터가 빌 때까지 suspend된다.

   한편 생산자-소비자에서 생산자가 버퍼가 꽉 차면 기다려야하듯이, 프로세스가 진행을 멈춰야할 때가 있다. 모니터 내부의 조건 변수와 wait, signal 연산으로 이것을 해결할 수 있다. 프로세스가 더 이상 진행할 수 없음을 인식하면 조건 변수에 대해 wait 연산을 실행하고 조건 변수에 해당하는 큐에서 대기한다. 이때 새로운 프로세스가 모니터에 진입하여 모니터의 프로시저를 호출할 수 있게 된다. 조건을 만족하면 잠들어있는 프로세스를 깨우기 위해 signal 연산을 호출한다. 단, 모니터 내부에는 하나의 프로세스만 깨어있을 수 있다. signal을 수행한 프로세스가 즉시 나가고 깨어난 프로세스가 실행되거나, signal을 수행한 프로세스가 수행을 마치고 프로세스가 깨어나는 해법이 있다.

   한 번에 하나의 스레드가 실행되어야하거나 스레드 간의 협업이 필요할 때 사용한다.

   컴파일러가 상호배제를 달성하므로 프로그래머 입장에서는 세마포어를 사용할 때보다 쉽다. 하지만 상호배제가 컴파일러의 몫이므로 프로그래밍 언어가 모니터를 지원해야한다.

## 스터디

1. 뮤텍스가 무엇인가요

   뮤텍스는 락과 언락의 상태를 가지는 객체이다. 멀티 스레드에서 공유 자원과 임계구역에 대해 상호배제를 하기 위해 사용한다.

   1. 뮤텍스와 스핀락(바쁜 대기를 사용하는 lock)의 차이는 무엇인가

      뮤텍스는 락을 획득할 수 없으면 블록되어 문맥 교환되나 스핀락은 CPU 자원을 소유한 채 대기한다.

   2. 뮤텍스와 세마포어의 차이는 무엇인가

      뮤텍스는 객체이고 세마포어는 정수 변수다. 한 순간엔 하나의 스레드가 뮤텍스를 소유하지만 세마포어는 여러 프로세스나 스레드가 소유할 수 있다. 뮤텍스는 락을 건 스레드가 락을 해제할 수 있지만 세마포어는 세마포어를 획득하지 않은 스레드가 세마포어의 락을 해제할 수 있다.



## 참고

- 운영체제론(노상혁, 이동희, 천홍석, 최동우 공역)
- 운영체제론 강의 필기
- [OS는 할껀데 핵심만 합니다](https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-8%ED%8E%B8-Critical-section-%EC%9E%84%EA%B3%84-%EA%B5%AC%EC%97%AD)
- [geeksforgeeks - Introduction of Process Synchronization](https://www.geeksforgeeks.org/introduction-of-process-synchronization/?ref=lbp)
- [geeksforgeeks - Critical Section in Synchronization](https://www.geeksforgeeks.org/g-fact-70/?ref=lbp)
- [geeksforgeeks - Mutex vs Semaphore](https://www.geeksforgeeks.org/mutex-vs-semaphore/)
- [geeksforgeeks - Difference between Binary Semaphore and Mutex](https://www.geeksforgeeks.org/difference-between-binary-semaphore-and-mutex/)
- [Difference between Mutex and Semaphore in Operating System](https://afteracademy.com/blog/difference-between-mutex-and-semaphore-in-operating-system)
- [What is the Difference Between Spinlock and Mutex](https://pediaa.com/what-is-the-difference-between-spinlock-and-mutex/)
- [Difference between Spinlock and Mutex in Operating System](https://www.javatpoint.com/spinlock-vs-mutex-in-operating-system)
- [Monitors in Process Synchronization](https://www.geeksforgeeks.org/monitors-in-process-synchronization/)
- [스핀락(spinlock) 뮤텍스(mutex) 세마포(semaphore) 각각의 특징과 차이 완벽 설명! 뮤텍스는 바이너리 세마포가 아니라는 것도 설명합니다!](https://youtu.be/gTkvX2Awj6g)

