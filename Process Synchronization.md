# Process Synchronization

[IPC 공유 메모리 모델](https://github.com/leegwae/operating-system/blob/main/IPC.md#shared-memory)에서는 두 프로세스 간의 동기화가 필요하다. 공유 메모리에 있는 데이터는 프로세스의 접근 순서에 상관없이 무결성을 유지해야한다.



## 경쟁 상태

> 경쟁 상태의 정의와 임계구역의 정의, 그리고 임계구역 문제를 바람직하게 해결하기 위해 필요한 세 가지 조건을 알아본다.

**경쟁 상태(race condition)**는 공유 자원에 두 개 이상의 프로세스가 접근할 때 그 접근 순서에 따라 결과가 달라지는 상황을 뜻한다. **임계구역(critical section)**은 공유 자원에 접근하는 코드 영역을 의미한다. 즉, 임계구역에서 경쟁 상태가 발생한다. 

임계구역 문제를 바람직하게 해결하려면 세 가지 조건을 충족해야한다. 첫번째, 두 프로세스가 동시에 임계구역에 존재하지 않아야한다. 이를 **상호배제(mutual exclusion)**라고 하며, 한 프로세스가 임계구역에 진입하여 공유 메모리를 읽고 쓸 동안 다른 프로세스는 그러지 못하게 막아 구현한다. 상호배제만으로도 경쟁 상태를 피할 수 있다. (그러나 병렬 프로세스가 효율적이고 정확하게 공유 자원을 사용하기에는 부족하다.) 두번째, 임계구역 외부에서 실행되고 있는 프로세스가 다른 프로세스의 진입을 막으면 안된다(임계구역이 비어있으면 진입할 수 있어야 한다). 이를 **진행(progress)**이라고 한다. 두번째, 프로세스는 언젠가는 임계구역에 진입할 수 있어야 한다. 이를 **한계 대기(bounded waiting)**라고 한다. 



## 상호 배제 구현하기

상호 배제를 구현하는 방법에 대하여 알아본다.

### 인터럽트 끄기

프로세스가 임계구역에 진입하면 인터럽트를 꺼서 문맥 교환이 일어나지 않도록 하고 임계구역에서 나가기 적전에 인터럽트를 켠다. 그러나 인터럽트를 끄고 켜는 것은 커널의 고유 권한이다. 또한 프로세스가 인터럽트를 건다면 자신을 실행하는 CPU에만 영향을 끼치므로 CPU가 여러 개일 경우 유효하지 않은 방법이다.

### 하나의 공유 락 변수 사용하기

```
while (lock == 1);
lock = 1;
임계구역;
lock = 0;
```

공유 락 변수를 확인하여 `0`이면 공유 락을 `1`로 설정하고 임계구역에 진입한다. 임계구역을 수행한 후 나올 때 공유 락을 `0`을 설정해준다. 다른 프로세스는 공유 락 변수가 `1`이므로 `0`이 될 때까지 기다린다. 그런데 다음과 같은 경우를 생각해보자. `A` 프로세스가 임계구역에 진입하기 위해 락을 걸기 직전, 다른 프로세스 `B`가 스케줄되어 락을 건다. 그리고 다시 스케줄된 `A`가 락을 건다면 임계구역에는 `A`와 `B`가 동시에 존재하게 된다. 이것은 첫번째 조건인 상호 배제를 위반한다.

### 두 개의 락 공유 변수 사용하기

```
// 프로세스 A
lock1 = true;
while (lock2 == true);
임계구역;
lock1 = false;
```

```
// 프로세스 B
lock2 = true;
while (lock1 == true);
임계구역;
lock2 = false;
```

각각의 프로세스는 락을 건 후 상대방이 락을 풀 때까지 대기한다. 임계구역에 진입하고 나올 때 자신의 락을 푼다. 그런데 다음과 같은 경우를 생각해보자. 프로세스 `A`가 락을 건 후 문맥 교환이 일어나 프로세스 `B`가 실행되었다. 프로세스 `B` 역시 락을 걸었고 다시 문맥 교환이 일어나 프로세스 `A`가 실행된다. 이때 프로세스 `A`와 프로세스 `B`는 모두 락을 건 상태이고 임계구역은 비어있다. 프로세스 `A`는 `B`가 락을 걸었으므로 대기하고, 할당된 CPU 시간을 다 써 프로세스 `B`로 스케줄링된다. 프로세스 `B`는 프로세스 `A`가 락을 걸었으므로 대기하고, 할당된 CPU 시간을 다 써 프로세스 `A`로 스케줄링된다. 이것은 두번째 조건인 한계 대기를 위반하며, 두 프로세스 모두 무한한 대기에 머무르는 교착 상태(데드락;deadlock)에 빠지게 된다.

### 엄격한 교대

```
// 프로세스 A: lock이 0이 될 때까지 대기(lock이 0이 아니면 대기)
while (TRUE) {
	while (lock != 0);
	임계구역
	lock = 1;
	비임계구역
}
```

````
// 프로세스 B: lock이 1이 될 때까지 대기(lock이 1이 아니면 대기)
while (TRUE) {
	while (lock != 1);
	임계구역
	lock = 0;
	비임계구역
}
````

두 프로세스는 각자 `0`과 `1`이라는 값을 가지고 공유 락 변수가 해당 값이 될 때까지 기다린다. 이렇게 변수가 특정 값이 될 때까지 검사하는 것을 **바쁜 대기(busy waiting)**라고 하며 바쁜 대기를 사용하는 락을 스핀 락(spin lock)이라고 한다. 프로세스는 자신의 락 값이 될 때까지 기다린다. 락 값이 자신의 값이 된다면 임계구역을 수행하고 락을 다른 프로세스의 값으로 설정하고 비임계구역을 수행한다.

그러나 다음과 같은 경우를 생각해보자. 프로세스 `A`는 임계구역을 떠나며 락을 `1`로 설정했다. 프로세스 `B`는 락이 `1`로 설정되었으니 재빨리 임계구역에 진입하여 일을 처리한 후 락을 `0`으로 설정하고 비임계구역을 수행한다. 이때 락은 `0`이고 두 프로세스 모두 비임계구역에 있다. 비임계구역 수행을 마친 `A`는 락이 `0`이 되었으므로 임계구역을 수행한다. 이후 임계구역을 떠나며 락을 `1`로 설정하고 비임계구역을 수행한다. 이때 락은 `1`이고 두 프로세스는 비임계구역에 있다. 그런데 `A`의 수행 속도가 빨라, 비임계구역의 일을 마치고 다시 락이 `0`이 되기를 기다린다. 즉, 프로세스의 수행 속도가 느리다면 다른 프로세스는 계속 기다려야한다. 이 경우 비임계구역의 프로세스 `B`가 `A`의 임계구역 진입을 막고 있다. 이것은 세번째 조건인 진행을 위반한다. 또한 바쁜 대기의 특성상 프로세스가 계속 값을 검사하며 기다리므로 CPU 시간이 낭비된다.

또다른 경우를 생각해보자. 프로세스 `A`는 프로세스 `B`보다 높은 우선순위를 가져, `A`가 준비 상태이면 항상 `A`가 수행된다. 그런데 `B`가 임계구역에 진입하고 `A`가 준비 상태가 되었다. `A`는 스케줄링 규칙에 따라 실행되어 임계구역에 진입하기 위해 바쁜 대기를 수행한다. 그러나 `B`는 `A`가 실행 중(바쁜 대기 중)이므로 스케줄 되지 못해 임계구역을 벗어나지 못하며 `A`는 `B`가 임계구역에서 벗어나지 못하니 두 프로세스 모두 영원히 대기하게 된다. 이러한 상황을 **우선순위 역전 문제(priority inversion problem)**라고 하며, 교착 상태에 빠졌다고 한다.

### sleep-wakeup 연산자

바쁜 대기는 CPU 시간을 낭비한다. sleep-wakeup 연산자는 블로킹을 사용하여 이 문제를 해결한다. `sleep`는 호출자를 블록 상태로 만들어 다른 프로세스가 호출자를 깨울 때까지 블로킹된다. `wakeup`은 인자로 전달된 프로세스를 깨운다.



## 생산자-소비자 문제

```
// 생산자 프로세스
버퍼에 넣기;
count += 1; 	// 임계구역
```

```
// 소비자 프로세스
버퍼에서 빼기;
count -= 1;		// 임계구역
```

`생산자` 프로세스와 `소비자` 프로세스는 고정 크기의 버퍼를 공유한다. `생산자`는 맨 앞에서부터 정보를 저장하고, `소비자`는 맨 뒤에서부터 정보를 꺼낸다. 이때 버퍼에 들어있는 데이터의 개수를 나타내는 `count`가 임계구역이 된다. 만일 소비자나 생산자가 버퍼를 건드린 후 `count`를 갱신하지 못한 채 상대 프로세스로 문맥교환된다면 경쟁 상태가 발생할 수 있다.



## 생산자-소비자 문제 해결하기

### sleep-wakeup 연산자

```C
#define N 100
int count = 0;

void 생산자(void){
    int item;
    
    while (TRUE) {
        item = produce_item();
        if (count == N) sleep();
        insert_item(item);
        count += 1;
        if (count == 1) wakeup(consumer);
    }
}

void 소비자(void){
    int item;
    
    while (TRUE) {
        if (count == 0) sleep();
        item = remove_item();
        count -= 1;
        if (count == N - 1) wakeup(consumer);
        consume_item(item);
    }
}
```

`생산자`는 버퍼가 꽉 차면 잠들고 `소비자`는 버퍼가 텅 비면 잠든다. `소비자`가 데이터를 하나 꺼내 버퍼에 빈 공간이 생기면 생산자를 깨우고 `생산자`는 데이터를 하나 만들어 버퍼에 데이터가 한 개 있으면 소비자를 깨운다.

그런데 버퍼의 데이터 개수를 저장하는 변수 `count`에 경쟁 상태가 발생할 수 있다. 버퍼가 비고 소비자는 개수가 `0`임을 알았다(`if (count ==0)`). 이때 스케줄러가 소비자를 중지시키고 생산자를 실행하는데, 생산자는 데이터를 버퍼에 추가하고 개수를 `1`로 증가시킨다. 개수가 `1`이므로 생산자는 소비자를 깨운다. 그리고 스케줄러가 생산자를 중지시키고 소비자를 실행하는데, 소비자는 개수가 `0`이라고 알고 있으므로 잠들게 된다. 다시 스케줄러에 의해 생산자가 실행되고 생산자는 버퍼를 꽉 채운 후 잠든다. 생산자와 소비자는 영원히 잠들게 되어 교착 상태에 빠진다.

이렇게 '깨움이 소실되는' 문제는 프로세스가 버퍼에 데이터 개수를 저장하는 변수를 확인하고, 조건에 부합하면 잠들기까지의 두 연산이 원자적(atomic)이지 않기 때문이다(`if (count ==0) sleep()`). 소비자가 `0`임을 확인하고 잠들기까지가 하나의 연산처럼 원자적으로 이루어져야 하나 중간에 생산자가 스케줄링되어 문제가 발생한다. 커널이 제공하는 세마포어, 뮤텍스, 모니터를 사용한다면 원자적 연산을 구현할 수 있다.



## 참고

- [OS는 할껀데 핵심만 합니다](https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-8%ED%8E%B8-Critical-section-%EC%9E%84%EA%B3%84-%EA%B5%AC%EC%97%AD)
- [geeksforgeeks - Introduction of Process Synchronization](https://www.geeksforgeeks.org/introduction-of-process-synchronization/?ref=lbp)
- [geeksforgeeks - Critical Section in Synchronization](https://www.geeksforgeeks.org/g-fact-70/?ref=lbp)
- 운영체제론(노상혁, 이동희, 천홍석, 최동우 공역)
- 운영체제론 강의 필기

