# IPC

**IPC(inter-process communication; 프로세스 간 통신)**은 프로세스들이 서로 데이터를 주고 받는 행위나 그에 대한 방법을 뜻한다. IPC는 크게 공유 메모리 방식과 메시지 패싱 방식으로 나눌 수 있다.



## Shared Memory

**공유 메모리(shared memory)** 방식에 대하여 알아보자. 프로세스가 커널에 공유 메모리 할당을 요청하면, 커널은 공유 메모리를 할당하고 이것을 프로세스의 가상 메모리 공간에 매핑한다. 이제 어떤 프로세스든 자신의 가상 메모리에 공유 메모리를 매핑한다면 할당된 공유 메모리에 접근할 수 있다. 공유 메모리를 사용하는 프로세스 간의 통신은 커널이 관여하지 않으며 프로그래머가 구현한다. 

공유 메모리 방식은 메모리를 공유하기 때문에 쓰기가 두 번 이루어지지 않으므로 두 프로세스 간의 통신이 잦다면 매우 효과적이다. 통신에는 커널이 관여하지 않아 빠르기도 하다. 그러나 커널이 공유 메모리를 사용하는 모든 프로세스의 가상 메모리에 공유 메모리를 매핑하는 것은 느린 작업이다. 또한 두 프로세스가 동시에 공유 메모리에 접근하면 그 순서에 따라 결과를 예측할 수 없게 된다. 따라서 프로그래머는 반드시 두 프로세스를 동기화해야 하는 문제가 있다.



> 프로세스 동기화는 [다음](https://github.com/leegwae/operating-system/blob/main/Process%20Synchronization.md)을 참고한다.



## Message Passing

**메시지 패싱(message passing)** 방식에 대하여 알아보자. 발신 프로세스가 전달하려는 메시지를 버퍼에 담고 시스템 호출을 한다. 커널은 버퍼에서 데이터를 읽어 커널의 메모리 영역에 복사한다. 수신 프로세스는 메시지를 전달받고자 시스템 호출을 하고, 커널은 메모리에 있는 데이터를 수신 프로세스의 버퍼에 쓴다. 최종적으로 수신 프로세스가 버퍼에 담긴 데이터를 읽게 된다. 발신자와 수신자는 블로킹되거나 블로킹되지 않을 수 있는데, 총 세 가지 종류가 있다. 첫번째, 발신자와 수신자가 블로킹된다. 발신자와 수신자 모두 수신자가 메시지를 전달받을 때까지 멈춰있다. 두번째, 발신자와 수신자가 논블로킹된다. 발신자는 메시지를 보낸 후 자신의 일을 계속하며, 수신자는 메시지를 기다리며 멈춰있지 않고 자신의 일을 계속하고 있다. 세번째, 발신자는 논블로킹되고 수신자는 블로킹된다. 발신자는 메시지를 보낸 후 자신의 일을 계속하며, 수신자는 메시지를 기다리며 멈춰있다. 이 조합이 가장 일반적인 방법이다. 한편, 수신자와 발신자가 서로를 명시하는 방법에는 두 종류가 있다. direct addressing에서 수신자와 발신자는 서로의 이름을 명시하는 반면, indirect addressing에서 발신자와 수신자는 커널 내부의 동일한 포트 번호를 명시한다. 후자의 경우 수신자가 특정 포트 번호에 데이터를 저장하면 발신자가 해당 번호를 찾아 꺼내가는 방식으로 다대다 연결이 가능하다.

메시지 패싱 방식은 커널이 두 프로세스 간의 통신에 관여하므로 통신이 잦다면 비효율적이다. 그러나 공유 메모리를 사용하지 않으므로 동기화를 필요로 하지 않는다는 장점이 있다.



## 참고

- 운영체제 강의 필기
- [OpenCSF-IPC 모델](https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/IPCModels.html)
- [GeeksforGeeks - IPC](https://www.geeksforgeeks.org/inter-process-communication-ipc/)
- [제이온 - IPC](https://steady-coding.tistory.com/508)

