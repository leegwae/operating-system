# Process Synchronization

[IPC 공유 메모리 모델](https://github.com/leegwae/operating-system/blob/main/IPC.md#shared-memory)에서는 두 프로세스 간의 동기화가 필요하다. 공유 메모리에 있는 데이터는 프로세스의 접근 순서에 상관없이 무결성을 유지해야한다.



## 경쟁 상태

> 경쟁 상태의 정의와 임계구역의 정의, 그리고 임계구역 문제를 바람직하게 해결하기 위해 필요한 세 가지 조건을 알아본다.

**경쟁 상태(race condition)**는 공유 자원에 두 개 이상의 프로세스가 접근할 때 그 접근 순서에 따라 결과가 달라지는 상황을 뜻한다. **임계구역(critical section)**은 공유 자원에 접근하는 코드 영역을 의미한다. 즉, 임계구역에서 경쟁 상태가 발생한다. 

임계구역 문제를 바람직하게 해결하려면 세 가지 조건을 충족해야한다. 첫번째, 두 프로세스가 동시에 임계구역에 존재하지 않아야한다. 이를 **상호배제(mutual exclusion)**라고 하며, 한 프로세스가 임계구역에 진입하여 공유 메모리를 읽고 쓸 동안 다른 프로세스는 그러지 못하게 막아 구현한다. 상호배제만으로도 경쟁 상태를 피할 수 있다. (그러나 병렬 프로세스가 효율적이고 정확하게 공유 자원을 사용하기에는 부족하다.) 두번째, 임계구역 외부에서 실행되고 있는 프로세스가 다른 프로세스의 진입을 막으면 안된다(임계구역이 비어있으면 진입할 수 있어야 한다). 이를 **진행(progress)**이라고 한다. 두번째, 프로세스는 언젠가는 임계구역에 진입할 수 있어야 한다. 이를 **한계 대기(bounded waiting)**라고 한다. 



## 임계구역 문제 해결하기

변수가 특정 값이 될 때까지 계속 검사하는 것을 **바쁜 대기(busy waiting)**이라고 한다. 락이 바쁜 대기를 사용한다면 스핀 락(spin lock)이라고도 한다. 

바쁜 대기를 사용하여 임계구역 문제를 해결하는 방법을 알아본다.

### 인터럽트 끄기

프로세스가 임계구역에 진입하면 인터럽트를 꺼서 문맥 교환이 일어나지 않도록 하고 임계구역에서 나가기 적전에 인터럽트를 켠다. 그러나 인터럽트를 끄고 켜는 것은 커널의 고유 권한이다. 또한 프로세스가 인터럽트를 건다면 자신을 실행하는 CPU에만 영향을 끼치므로 CPU가 여러 개일 경우 유효하지 않은 방법이다.

### 하나의 공유 락 변수 사용하기

```
while (lock == 1);
lock = 1;
임계구역;
lock = 0;
```

프로세스는 공유 락 변수를 확인하여 `0`이면 공유 락을 `1`로 설정하고 임계구역에 진입한다. 임계구역을 수행한 후 나올 때 공유 락을 `0`을 설정해준다. 다른 프로세스는 공유 락 변수가 `1`이므로 `0`이 될 때까지 기다린다. 그런데 다음과 같은 경우를 생각해보자. `A` 프로세스가 임계구역에 진입하기 위해 락을 걸기 직전, 다른 프로세스 `B`가 스케줄되어 락을 건다. 그리고 다시 스케줄된 `A`가 락을 건다면 임계구역에는 `A`와 `B`가 동시에 존재하게 된다. 이것은 첫번째 조건인 상호 배제를 위반한다.

### 두 개의 락 공유 변수 사용하기

```
// 프로세스 A
lock1 = true;
while (lock2 == true);
임계구역;
lock1 = false;
```

```
// 프로세스 B
lock2 = true;
while (lock1 == true);
임계구역;
lock2 = false;
```

각각의 프로세스는 자신의 락을 건 후 상대방이 락을 풀 때까지 대기한다. 임계구역에 진입하고 나올 때 자신의 락을 푼다. 그런데 다음과 같은 경우를 생각해보자. 프로세스 `A`가 락을 건 후 문맥 교환이 일어나 프로세스 `B`가 실행되었다. 프로세스 `B` 역시 락을 걸었고 다시 문맥 교환이 일어나 프로세스 `A`가 실행된다. 이때 프로세스 `A`와 프로세스 `B`는 모두 락을 건 상태이고 임계구역은 비어있다. 프로세스 `A`는 `B`가 락을 걸었으므로 대기하고, 할당된 CPU 시간을 다 써 프로세스 `B`로 스케줄링된다. 프로세스 `B`는 프로세스 `A`가 락을 걸었으므로 대기하고, 할당된 CPU 시간을 다 써 프로세스 `A`로 스케줄링된다. 이것은 두번째 조건인 한계 대기를 위반하며, 두 프로세스 모두 무한한 대기에 머무르는 교착 상태(데드락; deadlock)에 빠지게 된다.

### 엄격한 교대

```
// 프로세스 A: lock이 0이 될 때까지 대기
while (TRUE) {
	while (lock != 0);
	임계구역;
	lock = 1;
	비임계구역;
}
```

````
// 프로세스 B: lock이 1이 될 때까지 대기
while (TRUE) {
	while (lock != 1);
	임계구역;
	lock = 0;
	비임계구역;
}
````

두 프로세스는 각자 `0`과 `1`이라는 값을 가지고 공유 락 변수가 해당 값이 될 때까지 기다린다. 락 값이 자신의 값이 된다면 임계구역을 수행하고 락을 다른 프로세스의 값으로 설정하고 비임계구역을 수행한다.

그러나 다음과 같은 경우를 생각해보자. 프로세스 `A`는 임계구역을 떠나며 락을 `1`로 설정했다. 프로세스 `B`는 락이 `1`로 설정되었으니 재빨리 임계구역에 진입하여 일을 처리한 후 락을 `0`으로 설정하고 비임계구역을 수행한다. 이때 락은 `0`이고 두 프로세스 모두 비임계구역에 있다. 비임계구역 수행을 마친 `A`는 락이 `0`이 되었으므로 임계구역을 수행한다. 이후 임계구역을 떠나며 락을 `1`로 설정하고 비임계구역을 수행한다. 이때 락은 `1`이고 두 프로세스는 비임계구역에 있다. 그런데 `A`의 수행 속도가 빨라, 비임계구역의 일을 마치고 다시 락이 `0`이 되기를 기다린다. 즉, 프로세스의 수행 속도가 느리다면 다른 프로세스는 계속 기다려야한다. 이 경우 비임계구역의 프로세스 `B`가 `A`의 임계구역 진입을 막고 있다. 이것은 세번째 조건인 진행을 위반한다. 또한 바쁜 대기의 특성상 프로세스가 계속 값을 검사하며 기다리므로 CPU 시간이 낭비된다.

### sleep-wakeup 연산자 사용하기

바쁜 대기는 CPU 시간을 낭비한다. sleep-wakeup 연산자는 블로킹을 사용하여 이 문제를 해결한다. `sleep` 연산자는 호출자를 블록 상태로 만들어 다른 프로세스가 호출자를 깨울 때까지 블로킹된다. `wakeup` 연산자는 인자로 전달된 프로세스를 깨운다.



## 생산자-소비자 문제

```
// 생산자 프로세스
버퍼에 넣기;
count += 1; 	// 임계구역
```

```
// 소비자 프로세스
버퍼에서 빼기;
count -= 1;		// 임계구역
```

`생산자` 프로세스와 `소비자` 프로세스는 고정 크기의 버퍼를 공유한다. `생산자`는 맨 앞에서부터 정보를 저장하고, `소비자`는 맨 뒤에서부터 정보를 꺼낸다. 이때 버퍼에 들어있는 데이터의 개수를 나타내는 `count`가 임계구역이 된다. 만일 소비자나 생산자가 버퍼를 건드린 후 `count`를 갱신하지 못한 채 상대 프로세스로 문맥교환된다면 경쟁 상태가 발생할 수 있다.



## 생산자-소비자 문제 해결하기

### sleep-wakeup 연산자 사용하기

```C
#define N 100
int count = 0;

void 생산자(void){
    int item;
    
    while (TRUE) {
        item = produce_item();
        if (count == N) sleep();
        insert_item(item);
        count += 1;
        if (count == 1) wakeup(consumer);
    }
}

void 소비자(void){
    int item;
    
    while (TRUE) {
        if (count == 0) sleep();
        item = remove_item();
        count -= 1;
        if (count == N - 1) wakeup(consumer);
        consume_item(item);
    }
}
```

`생산자`는 버퍼가 꽉 차면 잠들고 `소비자`는 버퍼가 텅 비면 잠든다. `소비자`가 데이터를 하나 꺼내 버퍼에 빈 공간이 생기면 생산자를 깨우고 `생산자`는 데이터를 하나 만들어 버퍼에 데이터가 한 개 있으면 소비자를 깨운다.

그런데 버퍼의 데이터 개수를 저장하는 변수 `count`에 경쟁 상태가 발생할 수 있다. 버퍼가 비고 소비자는 개수가 `0`임을 알았다(`if (count ==0)`). 이때 스케줄러가 소비자를 중지시키고 생산자를 실행하는데, 생산자는 데이터를 버퍼에 추가하고 개수를 `1`로 증가시킨다. 개수가 `1`이므로 생산자는 소비자를 깨운다. 그리고 스케줄러가 생산자를 중지시키고 소비자를 실행하는데, 소비자는 개수가 `0`이라고 알고 있으므로 잠들게 된다. 다시 스케줄러에 의해 생산자가 실행되고 생산자는 버퍼를 꽉 채운 후 잠든다. 생산자와 소비자는 영원히 잠들게 되어 교착 상태에 빠진다.

이렇게 '깨움이 소실되는' 문제는 프로세스가 버퍼에 데이터 개수를 저장하는 변수를 확인하고, 조건에 부합하면 잠들기까지의 두 연산이 원자적(atomic)이지 않기 때문이다. 소비자가 `0`임을 확인하고 잠들기까지(`if (count ==0) sleep()`)가 하나의 연산처럼 원자적으로 이루어져야 하나, 중간에 생산자가 스케줄링되어 문제가 발생하는 것이다.



## 원자적 연산

어떻게 원자적 연산을 구현할 수 있을까? 커널이 제공하는 세마포어, 뮤텍스, 모니터를 사용한다면 원자적 연산을 구현할 수 있다. 

### 세마포어

다익스트라는 sleep과 wakeup 연산자가 일반화된 down과 up 연산을 제안한다.

```c
struct semaphore {
	int count;			// wake up 개수, 사용 가능한 자원의 개수를 의미한다.
	queueType queue;
}

void down(semaphore s)
{
    // 사용 가능한 자원이 있다면
	if (s.count > 0) s.count -= 1; // 자원을 하나 사용한다.
	else {
		프로세스를 s.queue에 넣는다;	// 사용할 수 있는 자원이 없다면 프로세스가 잠든다.
	}
}

void up(semaphore s) {
    s.count += 1; // 사용했던 자원을 하나 반납한다.
    // 세마포어 s에 잠들어있는 프로세스가 하나 이상이라면
	if (s.queue에 프로세스가 있다면) {
		프로세스 하나를 s.queue에서 꺼낸다;	// 프로세스를 깨운다.
		깨운 프로세스를 레디 큐로 보낸다;
	}
}
```

세마포어(semaphore)는 `down`과 `up` 연산자를 사용한다. 이 두 연산자는 원자적 연산으로, 연산이 완료되거나 프로세스가 잠들기 전까지 다른 프로세스가 세마포어에 접근할 수 없도록 보장한다. `down` 연산은 세마포어의 값이 0보다 크다면 값을 감소시키고 임계구역에 진입하지만 값이 0이라면 그 즉시 프로세스는 잠들게 된다. `up` 연산은 값을 증가시키는데, 잠들어있는 프로세스가 있다면 그 중 하나를 선택하여 깨운다. wake up 신호를 받아 깨어난 프로세스는 `down` 연산의 수행을 완료할 수 있다.

세마포어 연산은 원자적이므로 깨움이 소실되는 문제는 해결하며, 바쁜 대기를 하지 않고 블로킹을 사용하여 효율적이지만 일반적으로 시스템 콜의 형태로 구현되어 오버헤드가 있다.

### 세마포어와 생산자-소비자 문제

```c
#define N 100			// 버퍼 크기
typedef int semaphore;
semaphore mutex = 1;	// 임계구역에 진입할 때 사용
semaphore empmty = N;	// 남아있는 버퍼 크기
semaphore full = 0;		// 사용한 버퍼 크기

void producer(void) {
	int item;
    
    while (TRUE) {
        item = product_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer(void) {
    int item;
    
    while (TRUE) {
        down(&full);
        down(&mutex);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}
```

이 문제에서 임계 구역은 버퍼가 된다. `mutex` 세마포어는 임계구역인 버퍼에 대한 상호 배제를 위해 사용되었다. `empty` 세마포어와 `full` 세마포어는 동기화 문제를 해결하기 위해 사용되었다.

생산자는 아이템을 버퍼에 넣기 전 남아있는 버퍼 크기를 나타내는 `empty` 세마포어와 임계구역에 다른 프로세스가 진입해있는지 나타내는 `mutex` 세마포어에 대해 차례로 `down` 연산을 실행한다. `empty` 세마포어에서 잠든다면 그것은 버퍼가 꽉 찼다는 뜻이므로 소비자가 `empty` 세마포어에 대하여 `up` 연산을 실행하면 깨어난다. 이후 `mutex` 세마포어에 `down` 연산을 실행하여 임계구역에 락을 건다. 임계구역에 진입한 생산자는 버퍼에 아이템을 하나 넣고 임계구역을 빠져나온다. `mutex`를 `up`하여 소비자가 임계구역에 진입할 수 있도록 락을 풀고, `full`를 `up`하여 잠들어있는 소비자를 깨워준다.

소비자는 `full` 세마포어와 `mutex` 세마포어에 대하여 차례로 `down` 연산을 실행한다. `full` 세마포어에서 잠든다면 그것은 버퍼가 비어있다는 뜻이므로 생산자가 `full` 세마포어에 대하여 `up` 연산을 실행하면 깨어난다. 이후 `mutex` 세마포어에 `down` 연산을 실행하여 임계구역에 락을 건다. 임계구역에 진입한 소비자는 버퍼에서 아이템을 하나 꺼내고 임계구역을 빠져나온다. `mutex`를 `up`하여 생산자가 임계구역에 진입할 수 있도록 락을 풀고, `empty`를 `up`하여 잠들어있는 생산자를 깨워준다.

-> TODO: 식사하는 철학자 문제

### 이진 세마포어

위 생산자 소비자 문제에서 사용된 `mutex` 세마포어는 0(언락)과 1(락)이라는 두 개의 값을 가지므로 이진 세마포어(binary semaphore)이다. 이진 세마포어는 세마포어로 공유 자원이나 임계구역에 대하여 상호 배제를 구현할 때 사용한다. `wait`과 `signal` 연산을 가지는데 세마포어의 `down`과 `up` 연산과 내부 구현이 동일하다.

### 뮤텍스

**뮤텍스(mutex)**는 상호 배제(**mut**ual **ex**clusion)의 약자로, 공유 자원이나 임계구역에 대해 상호 배제를 할 때 사용한다. 한 시점에서 뮤텍스를 소유할 수 있는 스레드는 단 하나이므로, (이 뮤텍스를 소유하지 않은) 다른 스레드가 해당 뮤텍스에 걸린 락을 해제할 수 없다.

### 뮤텍스와 세마포어의 차이

세마포어는 정수 변수이다. 이 정수 변수는 사용할 수 있는 자원의 개수를 의미한다. 세마포어는 signaling 메커니즘에 기반하여, 자원을 사용하고 싶은 프로세스나 스레드는 자원이 없다면 세마포어에서 잠들고 다른 프로세스나 스레드의 wake up 신호에 의해 깨어난다. 그러므로 세마포어는 하나의 프로세스/스레드에게 독점되는 것이 아니며, 여러 개의 프로세스와 스레드가 동일한 세마포어를 획득한다. 달리 말하여 여러 개의 프로세스/스레드가 세마포어의 값을 변경할 수 있는데, 다만 한 번에 하나의 프로세스/스레드만이 변경할 수 있다. 세마포어의 특성상 자원의 인스턴스 수가 여러 개라면 세마포어를 사용하는 것이 적합하다.

뮤텍스는 객체이다. 이 객체는 멀티스레드 환경에서 임계구역에 대한 사용권을 획득하고 다른 스레드의 진입을 방지하기 위해 사용한다. 뮤텍스는 locking 메커니즘에 기반하여, 임계구역에 진입하려는 스레드가 뮤텍스에 대해 락을 걸고 뮤텍스를 소유한다. 그러므로 뮤텍스는 한 번에 하나의 스레드에게 독점되고(하나의 스레드에 의해서 락이 걸리고) 해당 스레드에 의해 락이 해제될 수 있다. 이때 락의 해제는 임계영역에서 나갈 때만 가능하다. 뮤텍스의 특성상 자원의 인스턴스가 한 개라면 뮤텍스를 사용하는 것이 적합하다.





## 참고

- [OS는 할껀데 핵심만 합니다](https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-8%ED%8E%B8-Critical-section-%EC%9E%84%EA%B3%84-%EA%B5%AC%EC%97%AD)
- [geeksforgeeks - Introduction of Process Synchronization](https://www.geeksforgeeks.org/introduction-of-process-synchronization/?ref=lbp)
- [geeksforgeeks - Critical Section in Synchronization](https://www.geeksforgeeks.org/g-fact-70/?ref=lbp)
- [geeksforgeeks - Mutex vs Semaphore](https://www.geeksforgeeks.org/mutex-vs-semaphore/)
- [geeksforgeeks - Difference between Binary Semaphore and Mutex](geeksforgeeks.org/difference-between-binary-semaphore-and-mutex/)
- [Difference between Mutex and Semaphore in Operating System](Difference between Mutex and Semaphore in Operating System)
- 운영체제론(노상혁, 이동희, 천홍석, 최동우 공역)
- 운영체제론 강의 필기

